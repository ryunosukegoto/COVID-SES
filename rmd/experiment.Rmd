---
title: "Preventing social isolation"
author: "Ryunosuke Goto"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}

#to run RMD
#library(rmarkdown)
#rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
#rmarkdown::render(paste(rootdir,"rmd/experiment.Rmd", sep="/"))

knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(tidyr)
library(ggplot2)
library(arsenal)
library(gridExtra)
library(ggpubr)
library(cowplot)
library(grid)
library(MASS)
library(knitr)
library(igraph)
library(data.table)
library(Rtsne)
library(caret)
library(pdp)
library(dtwclust)
library(randomForest)
library(igraph)
library(viridis)
library(RJSONIO)
library(RCurl)

rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]

source(paste(rootdir,"R/experiment.R",sep="/"))
sampleList <- experiment(redo=TRUE) #set redo=TRUE to update

totalRounds = 60
#refLevel = "normal" #MTurk
refLevel = "random" #Prolific

sample.long = sampleList[[1]]
sample.wide = sampleList[[2]]
g.isolation = sampleList[[3]]

#define isolation
degreeIsolation=0

sample.wide$isolated = ifelse(sample.wide$degree.1<=degreeIsolation | sample.wide$degree.2<=degreeIsolation | sample.wide$degree.3<=degreeIsolation | sample.wide$degree.4<=degreeIsolation | sample.wide$degree.5<=degreeIsolation| sample.wide$degree.6<=degreeIsolation | sample.wide$degree.7<=degreeIsolation | sample.wide$degree.8<=degreeIsolation | sample.wide$degree.9<=degreeIsolation | sample.wide$degree.10<=degreeIsolation | sample.wide$degree.11<=degreeIsolation | sample.wide$degree.12<=degreeIsolation | sample.wide$degree.13<=degreeIsolation
                              | sample.wide$degree.14<=degreeIsolation | sample.wide$degree.15<=degreeIsolation, 1, 0)

#isolation across treatment arms
table(sample.wide$isolated,sample.wide$arm)
aggregate(sample.wide$isolated, list(sample.wide$arm), FUN=sum, na.rm=TRUE)
prop.table(table(sample.wide$isolated,sample.wide$arm),2)

prop.table(table(sample.wide[sample.wide$arm!="low",]$arm, sample.wide[sample.wide$arm!="low",]$isolated),1)
prop.test(table(sample.wide[sample.wide$arm!="low",]$arm, sample.wide[sample.wide$arm!="low",]$isolated==0))

prop.table(table(sample.wide[sample.wide$arm!="high",]$arm, sample.wide[sample.wide$arm!="high",]$isolated),1)
prop.test(table(sample.wide[sample.wide$arm!="high",]$arm, sample.wide[sample.wide$arm!="high",]$isolated==0))

#loneliness
aggregate(sample.wide$loneliness.15, list(sample.wide$arm), FUN=mean, na.rm=TRUE)

#isolation rate
isoRate = data.frame(aggregate(sample.wide$isolated, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate) = c("arm","gameId","isoRate")
isoRate2 = data.frame(aggregate(is.na(unique(sample.wide$ID))==FALSE, list(sample.wide$arm,sample.wide$gameId), FUN=sum, na.rm=TRUE))
colnames(isoRate2) = c("arm","gameId","nPlayers")
isoRate = merge(isoRate,isoRate2,by=c("arm","gameId"))
isoRate3 = data.frame(aggregate(sample.wide$loneliness.15, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate3) = c("arm","gameId","loneliness")
isoRate = merge(isoRate,isoRate3,by=c("arm","gameId"))
isoRate4 = data.frame(aggregate(sample.wide$cumulativePayoff.15, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate4) = c("arm","gameId","cumulativePayoff")
isoRate = merge(isoRate,isoRate4,by=c("arm","gameId"))
isoRate5 = data.frame(aggregate(sample.wide$behavior.15=="C", list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate5) = c("arm","gameId","cooperationRate")
isoRate = merge(isoRate,isoRate5,by=c("arm","gameId"))
isoRate6 = data.frame(aggregate(sample.wide$behavior.1=="C", list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate6) = c("arm","gameId","cooperationRateInit")
isoRate = merge(isoRate,isoRate6,by=c("arm","gameId"))
isoRate7 = data.frame(aggregate(sample.wide$coefGlobal.0, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate7) = c("arm","gameId","coefGlobalInit")
isoRate = merge(isoRate,isoRate7,by=c("arm","gameId"))
isoRate8 = data.frame(aggregate(sample.wide$initialLoneliness, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate8) = c("arm","gameId","initialLoneliness")
isoRate = merge(isoRate,isoRate8,by=c("arm","gameId"))
isoRate9 = data.frame(aggregate(sample.wide$coefGlobal.15, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate9) = c("arm","gameId","coefGlobal")
isoRate = merge(isoRate,isoRate9,by=c("arm","gameId"))
isoRate10 = data.frame(aggregate(sample.wide$degree.15, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate10) = c("arm","gameId","degree")
isoRate = merge(isoRate,isoRate10,by=c("arm","gameId"))
isoRate11 = data.frame(aggregate(sample.wide$cumulativePayoff.15 <= quantile(sample.wide$cumulativePayoff.15,0.2,na.rm=TRUE), list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
colnames(isoRate11) = c("arm","gameId","propPoor")
isoRate = merge(isoRate,isoRate11,by=c("arm","gameId"))

#gini with na.rm
gini_mod = function(x, na.rm=TRUE) {
  if (na.rm==TRUE){
    return(reldist::gini(na.omit(x)))
  }
  if (na.rm==FALSE){
    return(reldist::gini(x))
  }
}

isoRate9 = data.frame(aggregate(sample.wide$cumulativePayoff.15, list(sample.wide$arm,sample.wide$gameId), FUN=gini_mod, na.rm=TRUE))
colnames(isoRate9) = c("arm","gameId","gini")
isoRate = merge(isoRate,isoRate9,by=c("arm","gameId"))
isoRate$arm = factor(isoRate$arm, levels=c(refLevel,"low","high")) 

isoRate <- isoRate %>%
  mutate(anyIsolation =
           case_when(
             isoRate==0 ~ 0,
             isoRate!=0 ~ 1
           ))
isoRate
aggregate(isoRate$isoRate,list(isoRate$arm),FUN=mean)
aggregate(isoRate$isoRate,list(isoRate$arm),FUN=sd)

#rounds with no isolation
table(isoRate$isoRate==0,isoRate$arm)
prop.table(table(isoRate$isoRate==0,isoRate$arm),2)["TRUE",]

#Cluster number and size
cluster=NULL
for(i in 1:totalRounds){
  cluster$arm[i] = V(g.isolation[[16*i]])$arm[1]
  cluster$gameId[i] = V(g.isolation[[16*i]])$gameId[1]
  cluster$nCommunities[i] = max(membership(cluster_louvain(g.isolation[[16*i]])),na.rm=TRUE)
  cluster$communitySize[i] = mean(table(membership(cluster_louvain(g.isolation[[16*i]]))),na.rm=TRUE)
}
cluster = data.frame(cluster)
cluster = merge(cluster,isoRate[c("gameId","isoRate","nPlayers")],by=c("gameId"))
aggregate(cluster$nCommunities, list(cluster$arm), FUN=mean, na.rm=TRUE)
aggregate(cluster$communitySize, list(cluster$arm), FUN=mean, na.rm=TRUE)
for(i in unique(cluster$arm)){
  plot = ggplot( aes(x=nCommunities), data=cluster[cluster$arm==i,]) +
    geom_histogram( color="#e9ecef", alpha=0.6, position = 'identity') +
    ggtitle(paste(i))
  print(plot)
}

cluster$arm = factor(cluster$arm, levels = c("random","low","high"))

#Evolution of cooperation
aggregate(sample.wide$behavior.1=="C", list(sample.wide$arm), FUN=mean, na.rm=TRUE)
aggregate(sample.wide$behavior.15=="C", list(sample.wide$arm), FUN=mean, na.rm=TRUE)

#Payoff
aggregate(sample.wide$cumulativePayoff.15, list(sample.wide$arm), FUN=mean, na.rm=TRUE)
```



#Isolation rate
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(isoRate ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("isoRate",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Percentage point difference in percentage of isolated individuals (ref: refLevel)
#glm(isoRate ~ arm, family = gaussian(link='identity'), data = d_reg)
kable(res_reg)


res = ggbarplot(data=isoRate, x="arm", y="isoRate", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.19998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Isolation rate") +
      annotate("text", x=1, y=0.2001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.20)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Loneliness
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(loneliness ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("loneliness",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Percentage point difference in probability in isolation rate (ref: refLevel)
kable(res_reg)


res = ggbarplot(data=isoRate, x="arm", y="loneliness", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 3.45, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Loneliness") +
      annotate("text", x=1, y=3.5, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,3.5)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Any isolation
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(anyIsolation ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("anyIsolation",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Percentage point difference in probability of any isolation (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="anyIsolation", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.89998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Probability of any isolation") +
      annotate("text", x=1, y=0.9001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.900)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```




#Payoff
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(cumulativePayoff ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("cumulativePayoff",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in payoff (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="cumulativePayoff", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 6000, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Cumulative payoff") +
      annotate("text", x=1, y=6000, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,6000)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Cooperation
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(cooperationRate ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("cooperationRate",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in cooperation rate (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="cooperationRate", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.89998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Cooperation rate") +
      annotate("text", x=1, y=0.9001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.90)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Gini
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(gini ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("gini",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in gini (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="gini", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.19998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Gini") +
      annotate("text", x=1, y=0.2001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.20)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```




#Global clustering coefficient
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(coefGlobal ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("coefGlobal",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in coefGlobal (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="coefGlobal", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.89998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Global clustering coefficient") +
      annotate("text", x=1, y=0.9001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.90)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Number of communities
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = cluster

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(nCommunities ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("nCommunities",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in nCommunities (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=cluster, x="arm", y="nCommunities", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 4.89998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Max number of communities") +
      annotate("text", x=1, y=4.9001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,5)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```


#Community size
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = cluster

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(communitySize ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("nCommunities",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in nCommunities (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=cluster, x="arm", y="communitySize", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 14.89998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Mean size of communities") +
      annotate("text", x=1, y=14.9001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,15)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```

#Degree
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(degree ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("degree",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in degree (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="degree", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 9.998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Degree") +
      annotate("text", x=1, y=10.001, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,10.0)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```



#Proportion of poor players
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
set.seed(123)
res_reg = NULL

d_reg = isoRate

createfmla <- function(yvar, xvars) {
  rhs <- paste(xvars, collapse=" + ")
  return(as.formula(paste(yvar, "~", rhs, sep=" ")))
}

# #impute with RF
# set.seed(123)
# d_l_mf <- d_l
# d_l_mf$state <- factor(d_l_mf$state)
# d_l_mf <- subset(d_l_mf, select=-c(fips))
# dimp <- missForest(xmis = d_l_mf, ntree=100, maxiter = 10, parallelize = 'no')
# # dimp$OOBerror
# # dimp$error
# d_l_rf<-cbind(d_l$fips, dimp$ximp)

#Exposure-outcome association
reg_main = glm(propPoor ~ arm, family = gaussian(link="identity"), data = d_reg)
reg_main.beta <- coef(reg_main)
reg_main.SE <- coef(summary(reg_main))[, 2]
reg_main.p <- coef(summary(reg_main))[, 4]
reg_main.lcl <- reg_main.beta - qnorm(0.975) * reg_main.SE
reg_main.ucl <- reg_main.beta + qnorm(0.975) * reg_main.SE
new_res = cbind("propPoor",reg_main.beta,reg_main.lcl,reg_main.ucl,reg_main.p)
res_reg = rbind(res_reg,new_res)


colnames(res_reg) = c("Outcome","Beta","LCL","UCL","P-value")
```

```{r}
#Difference in degree (ref: refLevel)
kable(res_reg)

res = ggbarplot(data=isoRate, x="arm", y="propPoor", add = "mean_se", color="arm") +
      stat_compare_means(ref.group = refLevel, label = "p.format", label.y = 0.4998, method="t.test", color="black", na.rm = TRUE) +  
      labs(
        #title = paste("Isolation when defectors are assigned to 25% of nodes by degree, ","V=",V,", Gini=",GINI,sep=""),
        x = "Treatment arm",
        y = "Proportion of poor players") +
      annotate("text", x=1, y=0.501, label= "ref", color="black") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, size=12),legend.position="none") +
      coord_cartesian(ylim=c(0,0.5)) + 
      scale_x_discrete(labels=c('Control','Low degree defectors','High degree defectors')) +
      scale_color_manual(values = c(refLevel = "black",'low'="black",'high'="black")) +
      geom_vline(xintercept = 1.5, linetype = "longdash")
print(res)
```


#Correlations
```{r}
ggplot(data=isoRate,aes(x=isoRate, y=cumulativePayoff)) + geom_point() + stat_cor() + 
  labs(x = "Isolation rate",y = "Average payoff") 
ggplot(data=isoRate,aes(x=isoRate, y=cooperationRate)) + geom_point() + stat_cor() + 
  labs(x = "Isolation rate",y = "Cooperation rate") 
ggplot(data=isoRate,aes(x=isoRate, y=gini)) + geom_point() + stat_cor() + 
  labs(x = "Isolation rate",y = "Gini") 
```


#Time series by treatment arm
```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'}
timeSeries = isoRate

library(reldist) # for gini calculation
#gini with na.rm
gini_mod = function(x, na.rm=TRUE) {
  if (na.rm==TRUE){
    return(gini(na.omit(x)))
  }
  if (na.rm==FALSE){
    return(gini(x))
  }
}

#gini mean difference (a.k.a. mean difference: please refer to https://stat.ethz.ch/pipermail/r-help/2003-April/032782.html)
gmd = function(x, na.rm=TRUE) {
  if(na.rm==TRUE){x1 = na.omit(x)}
   n = length(x1)
  tmp = 0
   for (i in 1:n) {
   for (j in 1:n) {
   tmp <- tmp + abs(x1[i]-x1[j])
   }
   }
  answer = tmp/(n*n)
  if(length(x)!=0){return(answer)}
  if(length(x)==0){return(NA)}
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("degree.",i,sep="")]==0, list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("isolationRate.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("cumulativePayoff.",i,sep="")], list(sample.wide$arm,sample.wide$gameId), FUN=gini_mod, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("gini.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("cumulativePayoff.",i,sep="")], list(sample.wide$arm,sample.wide$gameId), FUN=gmd, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("gmd.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}
            
for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("cumulativePayoff.",i,sep="")], list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("avg_wealth.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("behavior.",i,sep="")]=="C", list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("avg_coop.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("degree.",i,sep="")], list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("avg_degree.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

for(i in c(0:15)){
  timeSeries.2 = data.frame(aggregate(sample.wide[paste("coefGlobal.",i,sep="")], list(sample.wide$arm,sample.wide$gameId), FUN=mean, na.rm=TRUE))
  colnames(timeSeries.2) = c("arm","gameId",paste("clustCoefGlobal.",i,sep=""))
  timeSeries = merge(timeSeries,timeSeries.2,by=c("arm","gameId"))
}

timeSeries.long <- data.frame(
  timeSeries %>%
  pivot_longer(
    cols = starts_with("isolationRate") | starts_with("gini") | starts_with("gmd") |
           starts_with("avg_wealth") | starts_with("avg_coop") | starts_with("avg_degree") | starts_with("clustCoefGlobal"),
    names_to = c(".value", "round"),
    names_sep = "\\."
  ) 
)


plot.trends <- 
  data.frame(
    timeSeries.long %>% 
      group_by(round, arm) %>% 
      summarize_all(list(mean=~mean(., na.rm=TRUE),sd=~sd(., na.rm=TRUE)))
  )

plot.trends$round = as.numeric(plot.trends$round)

g.isolationRate = ggplot(data=plot.trends, aes(x=round,y=isolationRate_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = isolationRate_mean - isolationRate_sd, ymax = isolationRate_mean + isolationRate_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Isolation rate") +
  theme_bw() 

g.gini = ggplot(data=plot.trends, aes(x=round,y=gini_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = gini_mean - gini_sd, ymax = gini_mean + gini_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Gini coefficient") +
  theme_bw() 

g.gmd = ggplot(data=plot.trends, aes(x=round,y=gmd_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = gmd_mean - gmd_sd, ymax = gmd_mean + gmd_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Gini mean difference") +
  theme_bw() 

g.avg_wealth = ggplot(data=plot.trends, aes(x=round,y=avg_wealth_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = avg_wealth_mean - avg_wealth_sd, ymax = avg_wealth_mean + avg_wealth_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Average wealth") +
  theme_bw() 

g.avg_coop = ggplot(data=plot.trends, aes(x=round,y=avg_coop_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = avg_coop_mean - avg_coop_sd, ymax = avg_coop_mean + avg_coop_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  scale_y_continuous(limits = c(0, 1)) +
  ylab("Proportion of cooperation") +
  theme_bw() 

g.avg_degree = ggplot(data=plot.trends, aes(x=round,y=avg_degree_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = avg_degree_mean - avg_degree_sd, ymax = avg_degree_mean + avg_degree_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Average degree") +
  theme_bw() 
 
g.clustCoefGlobal = ggplot(data=plot.trends, aes(x=round,y=clustCoefGlobal_mean,group=arm)) +
  geom_line(aes(color=arm)) +
  geom_ribbon(aes(ymin = clustCoefGlobal_mean - clustCoefGlobal_sd, ymax = clustCoefGlobal_mean + clustCoefGlobal_sd, fill=arm),alpha=0.3) +
  xlab("Round")+
  ylab("Global clust coef") +
  theme_bw() 
  
  
plot <- ggarrange(g.isolationRate,g.gini,g.gmd,g.avg_wealth,g.avg_coop,g.avg_degree,g.clustCoefGlobal,common.legend = TRUE,legend="bottom")
```

```{r}
plot
```



<!-- #Time series clustering -->
<!-- ```{r, cache=FALSE, warning=FALSE, message=FALSE, echo=FALSE, results='hide'} -->
<!-- library(TSclust) -->
<!-- library(dtwclust) -->
<!-- sample.clust = timeSeries[c("isolationRate.1", -->
<!--                         "isolationRate.2","isolationRate.3", -->
<!--                         "isolationRate.4","isolationRate.5", -->
<!--                         "isolationRate.6","isolationRate.7", -->
<!--                         "isolationRate.8","isolationRate.9", -->
<!--                         "isolationRate.10","isolationRate.11", -->
<!--                        "isolationRate.12","isolationRate.13", -->
<!--                        "isolationRate.14","isolationRate.15")] -->

<!-- cluster.eval <- tsclust(sample.clust, k = 2L:13L, -->
<!--                    type="partitional", -->
<!--                    distance = "dtw", centroid = "pam", -->
<!--                    seed = 3247, trace = TRUE) -->

<!-- cluster.eval <- data.frame(sapply(cluster.eval,cvi)) -->
<!-- colnames(cluster.eval) <- c(2:13) -->

<!-- #Silhouette (Sil), score function (SF), Calinski-Harabasz index (CH), Dunn index (D) -->
<!-- #the local maximum is considered the appropriate number of clusters -->
<!-- cluster.eval[c("Sil","SF","CH","D"),] -->

<!-- #Davies-Bouldin index (DB), modified Davies-Bouldin index (DBstar), COP index (COP) -->
<!-- #the local minimum is considered the appropriate number of clusters -->
<!-- cluster.eval[c("DB","DBstar","COP"),] -->

<!-- #based on the above evaluations, -->
<!-- #4 clusters is determined to be the appropriate number of clusters -->
<!-- cluster <- tsclust(sample.clust, k = 4L, -->
<!--                    type="partitional", -->
<!--                    distance = "dtw", centroid = "pam", -->
<!--                    seed = 3247, trace = TRUE) -->




<!-- #####t-SNE##### -->
<!-- #scatter plot of data points; T-sne is used to reduce the dimensionality to two -->
<!-- library(dplyr) -->
<!-- library(Rtsne) -->
<!-- library(ggplot2) -->
<!-- sample.tsne = timeSeries[c("isolationRate.1", -->
<!--                        "isolationRate.2","isolationRate.3", -->
<!--                        "isolationRate.4","isolationRate.5", -->
<!--                        "isolationRate.6","isolationRate.7", -->
<!--                        "isolationRate.8","isolationRate.9", -->
<!--                        "isolationRate.10","isolationRate.11", -->
<!--                        "isolationRate.12","isolationRate.13", -->
<!--                        "isolationRate.14","isolationRate.15")] -->
<!-- clust = cbind( -->
<!--   timeSeries, -->
<!--   cluster = cluster@cluster -->
<!-- ) -->
<!-- colors = rainbow(length(unique(clust$cluster))) -->
<!-- names(colors) = unique(clust$cluster) -->
<!-- set.seed(1) -->
<!-- tsne = Rtsne(sample.tsne, dims = 2, perplexity=10, verbose=TRUE, max_iter = 500, check_duplicates = FALSE) -->

<!-- g.tsne <- ggplot(data.frame(tsne$Y),aes(x=tsne$Y[,1],y=tsne$Y[,2],color = as.factor(clust$cluster)))+ -->
<!--   geom_point() + -->
<!--   xlab("tSNE dimension 1") + -->
<!--   ylab("tSNE dimension 2") + -->
<!--   scale_color_discrete(name  ="Cluster") + -->
<!--   theme_classic() + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->


<!-- #####investigate clusters###### -->
<!-- #convert to long format -->
<!-- clust.res <- gather(cbind(timeSeries, cluster = cluster@cluster)[c("gameId", -->
<!--                                                                    "cluster", -->
<!--                        "isolationRate.1", -->
<!--                        "isolationRate.2","isolationRate.3", -->
<!--                        "isolationRate.4","isolationRate.5", -->
<!--                        "isolationRate.6","isolationRate.7", -->
<!--                        "isolationRate.8","isolationRate.9", -->
<!--                        "isolationRate.10","isolationRate.11", -->
<!--                        "isolationRate.12","isolationRate.13", -->
<!--                        "isolationRate.14","isolationRate.15")], -->
<!--                       round, isolationRate, -->
<!--                       isolationRate.1:isolationRate.15, factor_key=TRUE) -->

<!-- clust.res$round <- as.numeric(mapply(clust.res$round, FUN=function(t) gsub("isolationRate.","",x=t))) -->


<!-- clust.res$cluster <- factor(clust.res$cluster) -->


<!-- #plot each cluster and the time series that belong to each cluster -->
<!-- #plot(cluster, type = "sc") -->

<!-- #plot means and CIs -->
<!-- sum_clust <- clust.res %>% -->
<!--   group_by(round, cluster) %>% -->
<!--   summarise(mean = mean(isolationRate), -->
<!--             ci   = 1.96 * sd(isolationRate)/sqrt(n())) -->
<!-- pd <- position_dodge(width = 0.1) -->
<!-- # sum_clust %>% -->
<!-- #   ggplot(aes(x = round, y = mean, group = cluster)) + -->
<!-- #   geom_line(aes(color = cluster), position = pd) + -->
<!-- #   geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci, color=cluster), -->
<!-- #                 width = .1, position = pd) + -->
<!-- #   theme_bw() + -->
<!-- #   geom_point(size = 4, position = pd, aes(color=cluster)) + -->
<!-- #   labs( -->
<!-- #     title = "Trajectories of isolation rates", -->
<!-- #     x = "Round", -->
<!-- #     y = "Isolation rate", -->
<!-- #     color = NULL, -->
<!-- #     linetype = NULL) + -->
<!-- #   theme(plot.title = element_text(hjust = 0.5)) -->

<!-- aggregate(clust$cooperationRateInit,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$coefGlobalInit,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$initialLoneliness,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$cooperationRate,list(clust$cluster),FUN=mean) -->
<!-- table(clust$arm,clust$cluster) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #Silhouette (Sil), score function (SF), Calinski-Harabasz index (CH), Dunn index (D) -->
<!-- #the local maximum is considered the appropriate number of clusters -->
<!-- cluster.eval[c("Sil","SF","CH","D"),] -->
<!-- #Davies-Bouldin index (DB), modified Davies-Bouldin index (DBstar), COP index (COP) -->
<!-- #the local minimum is considered the appropriate number of clusters -->
<!-- cluster.eval[c("DB","DBstar","COP"),] -->
<!-- #tSNE -->
<!-- g.tsne -->
<!-- #Trajectories of isolation rates -->
<!-- sum_clust %>% -->
<!--   ggplot(aes(x = round, y = mean, group = cluster)) + -->
<!--   geom_line(aes(color = cluster), position = pd) + -->
<!--   geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci, color=cluster), -->
<!--                 width = .1, position = pd) + -->
<!--   theme_bw() + -->
<!--   geom_point(size = 4, position = pd, aes(color=cluster)) + -->
<!--   labs( -->
<!--     title = "Trajectories of isolation rates", -->
<!--     x = "Round", -->
<!--     y = "Isolation rate", -->
<!--     color = NULL, -->
<!--     linetype = NULL) + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- #Characteristics of clusters -->
<!-- aggregate(clust$cooperationRateInit,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$coefGlobalInit,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$initialLoneliness,list(clust$cluster),FUN=mean) -->
<!-- aggregate(clust$cooperationRate,list(clust$cluster),FUN=mean) -->
<!-- table(clust$arm,clust$cluster) -->
<!-- ``` -->

