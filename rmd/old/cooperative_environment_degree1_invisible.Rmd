---
title: "Does a cooperative environment affect isolation?"
author: "Ryunosuke Goto"
date: "10/19/2022"
output: html_document
---

```{r setup, include=FALSE}

#to run RMD
#library(rmarkdown)
#rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
#rmarkdown::render(paste(rootdir,"rmd/cooperative_environment_degree1_invisible.Rmd", sep="/"))

knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(tidyr)
library(ggplot2)
library(arsenal)
library(gridExtra)
library(ggpubr)
library(cowplot)
library(grid)
library(MASS)
library(knitr)
library(igraph)
library(data.table)
library(Rtsne)
library(caret)
library(pdp)
library(dtwclust)
library(randomForest)
library(igraph)

rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]

source(paste(rootdir,"R/degree.R",sep="/"))
sampleList <- degree(redo=TRUE) #set redo=TRUE to update

g.isolation = sampleList[[3]]
sample.wide = sampleList[[4]]
cdata = sampleList[[5]]
ndata = sampleList[[6]]

#define isolation
sample.wide$isolated = ifelse(sample.wide$degree.1<=1 | sample.wide$degree.2<=1 | sample.wide$degree.3<=1 | sample.wide$degree.4<=1 | sample.wide$degree.5<=1| sample.wide$degree.6<=1 | sample.wide$degree.7<=1 | sample.wide$degree.8<=1 | sample.wide$degree.9<=1 | sample.wide$degree.10<=1, 1, 0)
```



#Does allocating cooperative individuals to high-degree nodes prevent isolation?
```{r}
round = NULL
gameID = NULL 
nodes = NULL
meanDegree = NULL
meanDegreeCoop = NULL #mean degree among those who cooperated
meanDegreeDefect = NULL #mean degree among those who defected
meanDist = NULL #mean shortest path length divided by the maximum possible path length (Nvertices - 1)
maxDist = NULL #max shortest path length divided by the maximum possible path length (Nvertices - 1)
coefGlobal = NULL #global clustering coefficient
percentCoop = NULL #proportion of those who cooperated
percentCoopPopular = NULL #proportion of those who cooperated, among those with degree >=10
coopEnv = NULL 

for(i in 1:length(g.isolation)){
    round[i] =  mean(V(g.isolation[[i]])$round)
    gameID[i] = V(g.isolation[[i]])$gameID[1]
    nodes[i] = vcount(g.isolation[[i]])
    meanDegree[i] = mean(igraph::degree(g.isolation[[i]]),na.rm=TRUE)
    meanDegreeCoop[i] = mean(igraph::degree(g.isolation[[i]])[V(g.isolation[[i]])$behavior=="C"],na.rm=TRUE)
    meanDegreeDefect[i] = mean(igraph::degree(g.isolation[[i]])[V(g.isolation[[i]])$behavior=="D"],na.rm=TRUE)
    meanDist[i] = mean(distances(g.isolation[[i]])[distances(g.isolation[[i]])!=0 & distances(g.isolation[[i]])!=Inf],na.rm=TRUE) / length(V(g.isolation[[i]])-1)
    maxDist[i] = max(distances(g.isolation[[i]])[distances(g.isolation[[i]])!=0 & distances(g.isolation[[i]])!=Inf],na.rm=TRUE) / length(V(g.isolation[[i]])-1)
    coefGlobal[i] = transitivity(g.isolation[[i]], type="global")
    percentCoop[i] = prop.table(table(V(g.isolation[[i]])$behavior))["C"]
    percentCoopPopular[i] = prop.table(table(V(g.isolation[[i]])$behavior[igraph::degree(g.isolation[[i]])>=6]))["C"]
    coopEnv[i] = sum(ifelse(V(g.isolation[[i]])$behavior=="C",1,0)*igraph::degree(g.isolation[[i]])/sum(igraph::degree(g.isolation[[i]])),na.rm=TRUE)
}

smallWorld = data.frame(
  round = round,
  gameID = gameID,
  nodes = nodes,
  meanDegree = meanDegree,
  meanDegreeCoop = meanDegreeCoop,
  meanDegreeDefect = meanDegreeDefect,
  diffDegreeCD = meanDegreeCoop - meanDegreeDefect,
  meanDist = meanDist,
  maxDist = maxDist,
  coefGlobal = coefGlobal,
  percentCoop = percentCoop,
  percentCoopPopular = percentCoopPopular,
  coopEnv = coopEnv
)


round = NULL
gameID = NULL
visibleWealth = NULL
n=1
for(i in unique(cdata$round)){
  for(m in unique(cdata$gameID)){
    round[n] = as.numeric(i)-1
    gameID[n] = m
    visibleWealth[n] = ifelse(cdata[cdata$round==i & cdata$gameID==m,]$showScore[1]=="true",1,0)
    n=n+1
  }
}

smallWorld.2 = data.frame(
  round = round,
  gameID = gameID,
  visibleWealth = visibleWealth
)

smallWorld = merge(smallWorld, smallWorld.2, by=c("gameID","round"), all.x=TRUE)

smallWorld.initial = subset(smallWorld, smallWorld$round==0)

#percent of people that end up being isolated for each gameID
percentIsolated = NULL
percentIsolated = aggregate(isolated ~ gameID, data=sample.wide, FUN=max, na.rm=TRUE)
smallWorld.initial = merge(smallWorld.initial[c("gameID","meanDegree","meanDegreeCoop","meanDegreeDefect","diffDegreeCD","meanDist","coefGlobal","visibleWealth","percentCoop","percentCoopPopular","coopEnv")],percentIsolated, by="gameID", all.x=TRUE)

percentIsolated = NULL
percentIsolated = aggregate(isolated ~ gameID, data=sample.wide, FUN=mean, na.rm=TRUE)
percentIsolated = percentIsolated %>% rename(
  percentIsolated = isolated
)
smallWorld.initial = merge(smallWorld.initial,percentIsolated, by="gameID", all.x=TRUE)




reg = glm(isolated ~ coopEnv, 
      data = smallWorld.initial,
      family = binomial(link = "logit"))
summary(reg)

reg = glm(isolated ~ coopEnv*percentCoop, 
      data = smallWorld.initial,
      family = binomial(link = "logit"))
summary(reg)


reg = glm(percentIsolated ~ coopEnv, 
      data = smallWorld.initial, 
      family = gaussian(link = "identity"))
summary(reg)

reg = glm(percentIsolated ~ coopEnv*percentCoop, 
      data = smallWorld.initial, 
      family = gaussian(link = "identity"))
summary(reg)



# #MSM
# # estimation of denominator of ip weights
# #cooperatorの数以外は全てRandom（Erdos-Renyi random graphにより決まるため）なので、coopEnvはpercentCoopで調整すれば十分か
# den.fit.obj <- lm(coopEnv ~ percentCoop + I(percentCoop^2), data = smallWorld.initial)
# p.den <- predict(den.fit.obj, type = "response")
# dens.den <- dnorm(smallWorld.initial$coopEnv, p.den, summary(den.fit.obj)$sigma)
# 
# # estimation of numerator of ip weights
# num.fit.obj <- lm(coopEnv ~ 1, data = smallWorld.initial)
# p.num <- predict(num.fit.obj, type = "response")
# dens.num <- dnorm(smallWorld.initial$coopEnv, p.num, summary(num.fit.obj)$sigma)
# 
# smallWorld.initial$sw.a = dens.num/dens.den
# summary(smallWorld.initial$sw.a)
# 
# msm.sw.cont <-geepack::geeglm(isolated ~ coopEnv, 
#                  data=smallWorld.initial, weights=sw.a, family = binomial(link="logit"), id=gameID, corstr="independence")
# summary(msm.sw.cont)
# 
# msm.sw.cont <-geepack::geeglm(percentIsolated ~ coopEnv, 
#                  data=smallWorld.initial, weights=sw.a, family = gaussian(link="identity"), id=gameID, corstr="independence")
# summary(msm.sw.cont)


ggplot(data = smallWorld.initial, aes(x = coopEnv, y = percentIsolated)) + 
  geom_point() +
  ggtitle("Percent isolated") +
  scale_x_continuous("Cooporative environment") +  
  scale_y_continuous("Percent of individuals isolated") + 
  scale_fill_continuous(type = "viridis")


```

#Simulation 1
##Rate of cooperators is set constant
##All graphs start as Erdos-Renyi random newtorks
##Change where to place the cooperators in the network: 1. cooperators have low degrees
```{r simulation_C_low_degree}
#Define degrees of isolation
isolationDegree = 1

#number of iterations per arm
iterations = 500


df.netIntLowDegree = data.frame(
  coopFrac = NULL,
  avgCoop = NULL, 
  percentIsolation = NULL,
  isolation = NULL,
  percentIsolatedD = NULL
)


for(frac in c(0,0.05,0.1,0.15,0.2)){
  #nodes in the top fractionCoop degrees will automatically be a cooperator
  fractionCoop = frac
  
    coopFrac = NULL
    avgCoop = NULL
    percentIsolation = NULL
    isolation = NULL
    percentIsolatedD = NULL
    for(m in c(1:iterations)){
      # Section 1. NOTES, packages, and Parameters
      #Importing library
      library(igraph) # for network graphing
      library(reldist) # for gini calculatio
      library(boot) # for inv.logit calculation
      #Two prefixed functions
      #rank
      rank1 = function(x) {rank(x,na.last=NA,ties.method="average")[1]} #a smaller value has a smaller rank.
      #gini mean difference (a.k.a. mean difference: please refer to https://stat.ethz.ch/pipermail/r-help/2003-April/032782.html)
      gmd = function(x) {
       x1 = na.omit(x)
       n = length(x1)
      tmp = 0
       for (i in 1:n) {
       for (j in 1:n) {
       tmp <- tmp + abs(x1[i]-x1[j])
       }
       }
      answer = tmp/(n*n)
       return(answer)
      }
      # List of manipulating parameters of experiments
      #L : number of round
      #V : Visible or not
      #A : Income of a rich-group subject
      #B : Income of a poor-group subject
      #R : Probability to be assigned to a rich group
      #I : Number of the same-parameter trial
      #Example
      L = 10
      V = 0
      A = 700
      B = 300
      R = 0.5
      I = 0
      # List of fixed parameters of experiments (assumptions)
      #Rewiring rate = 0.3
      #GINI coefficient (can be known by A or B)
      GINI = 0*as.numeric(A==500) + 0.2*as.numeric(A %in% c(700,850)) + 0.4*as.numeric(A ==1150)
      #Collecting data frame (final output data frame)
      result = data.frame(round=0:L,n_par=NA,n_A=NA,avg_coop=NA,avg_degree=NA,avg_wealth=NA,gini=NA,gmd=NA,avg_coop_A=NA,avg_degree_A=NA,avg_wealth_A=NA,gini_A=NA,gmd_A=NA,avg_coop_B=NA,avg_degree_B=NA,avg_wealth_B=NA,gini_B=NA,gmd_B=NA,isolation=NA,percentIsolation=NA)
      #_A is for a richer group and _B is for a poorer group
      
      
      
      #####################################################
      # Section 2: Round 0 (Agents and environments)
      #Node data generation
      N = 17 # median of the number of participants over rounds.
      node_r0 = data.frame(ego_id=1:N, round=0)
      node_r0$group = sample(c("rich","poor"),N,replace=TRUE,prob=c(R,1-R)) #R is defined as the probability to be assigned to the rich group
      node_r0$initial_wealth = ifelse(node_r0$group=="rich",A,B)
      #Link data generation
      ego_list = NULL
      for (i in 1:N) { ego_list = c(ego_list,rep(i,N)) }
      link_r0 = data.frame(ego_id=ego_list,alt_id=rep(1:N,N))
      link_r0 = link_r0[(link_r0$ego_id < link_r0$alt_id),] #The link was bidirectional, and thus the half and self are omitted.
      link_r0$connected = sample(0:1,dim(link_r0)[1],replace=TRUE,prob=c(0.7,0.3)) #Initial rewiring rate is fixed, 0.3
      link_r0c_ego = link_r0[link_r0$connected==1,]
      link_r0c_alt = link_r0[link_r0$connected==1,]
      colnames(link_r0c_alt) = c("alt_id","ego_id","connected")
      link_r0c = rbind(link_r0c_ego,link_r0c_alt) #this is bidirectional (double counted) for connected ties.
      link_r0c = link_r0c[order(link_r0c$ego_id),]
      link_r0c$alternumber = NA #putting the number for each alter in the same ego
      link_r0c[1,]$alternumber = 1
      for (i in 1:(dim(link_r0c)[1]-1))
        {if (link_r0c[i,]$ego_id == link_r0c[i+1,]$ego_id)
          {link_r0c[i+1,]$alternumber = link_r0c[i,]$alternumber + 1}
        else
          {link_r0c[i+1,]$alternumber = 1}
        #print(i)
        }
      link_r0c2 = reshape(link_r0c, direction = "wide", idvar=c("ego_id","connected"), timevar="alternumber")
      link_r0c2$initial_degree = apply(link_r0c2[,colnames(link_r0c2)[substr(colnames(link_r0c2),1,6) == "alt_id"]],1,function(x){length(na.omit(x))}) #Degree of each ego
      link_r0c2[is.na(link_r0c2$initial_degree)==1,"initial_degree"] = 0
      #Reflect the degree and initial local gini coefficient into the node data
      node_r0 = merge(x=node_r0,y=link_r0c2,all.x=TRUE,all.y=FALSE,by="ego_id")
      node_r0$initial_avg_env_wealth = NA
      node_r0$initial_local_gini = NA #local gini coefficient of the ego and connecting alters
      node_r0$initial_rel_rank = NA #local rank of ego among the ego and connecting alters (divided by the number of the go and connecting alters)
      for (i in 1:(dim(node_r0)[1])){
        node_r0[i,]$initial_avg_env_wealth = mean(na.omit(node_r0[node_r0$ego_id %in%
        node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6) %in% c("ego_id","alt_id")]],"initial_wealth"]))
        node_r0[i,]$initial_local_gini = gini(na.omit(node_r0[node_r0$ego_id %in% node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6)
        %in% c("ego_id","alt_id")]],"initial_wealth"]))
        node_r0[i,]$initial_rel_rank = rank1(na.omit(node_r0[node_r0$ego_id %in% node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6)
        %in% c("ego_id","alt_id")]],"initial_wealth"]))/length(na.omit(node_r0[node_r0$ego_id %in%
        node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6) %in% c("ego_id","alt_id")]],"initial_wealth"]))
        }
      #Finalization of round 0 and Visualization
      #plot(graph.data.frame(link_r0[link_r0$connected==1,],directed=F)) #plot.igraph
      node_r0$everIsolated = 0
      result[result$round==0,2:20] = c(length(node_r0$ego_id),length(node_r0[node_r0$group=="rich",]$ego_id),NA,mean(node_r0$initial_degree),mean(node_r0$initial_wealth),gini(node_r0$initial_wealth),gmd(node_r0$initial_wealth),NA,mean(node_r0[node_r0$group=="rich",]$initial_degree),mean(node_r0[node_r0$group=="rich",]$initial_wealth),gini(node_r0[node_r0$group=="rich",]$initial_wealth),gmd(node_r0[node_r0$group=="rich",]$initial_wealth),NA,mean(node_r0[node_r0$group=="poor",]$initial_degree),mean(node_r0[node_r0$group=="poor",]$initial_wealth),gini(node_r0[node_r0$group=="poor",]$initial_wealth),gmd(node_r0[node_r0$group=="poor",]$initial_wealth),
                                       as.numeric(ifelse(is.na(table(node_r0$initial_degree<=isolationDegree)["TRUE"]),0,1)),
                                       as.numeric(sum(node_r0$everIsolated)/length(node_r0$ego_id)))
      
      #For the loop at the next round (for round 1, the initial one is the same as the previous [1 prior] one)
      node_import = node_r0
      node_import$initial_coop = NA
      node_import$prev_coop = NA
      node_import$prev_wealth = node_import$initial_wealth
      node_import$prev_degree = node_import$initial_degree
      node_import$prev_avg_env_wealth = node_import$initial_avg_env_wealth
      node_import$prev_local_gini = node_import$initial_local_gini
      node_import$prev_rel_rank = node_import$initial_rel_rank
      node_import$prev_local_rate_coop = NA
      link_import = link_r0
      
      
      
      #####################################################
      # Section 3: Rounds 1 to 10 or more (behaviors in simulation: the equation of cooperation is different at round 1 because of no history)
      #3-1: Cooperation phase
      for (k in 1:L)
      {
        node_rX = node_import #Importing data
        node_rX$round = node_rX$round + 1
        node_rX[is.na(node_rX$prev_degree)==1,"prev_degree"] = 0
        node_rX[is.na(node_rX$prev_local_rate_coop)==1,"prev_local_rate_coop"] = 0
        #Only this calculation needs to change from Round 1
        if (k==1) {
          node_rX$prob_coop = as.numeric(V==0)*inv.logit(0.9241803) + as.numeric(V==1)*inv.logit((-1.017021)*GINI + (0.8130213))
          } else {
          node_rX$prob_coop = as.numeric(V==0 & node_rX$prev_coop==0)*inv.logit(-1.039916) + as.numeric(V==0 & node_rX$prev_coop==1)*inv.logit(2.062023) + as.numeric(V==1 & node_rX$prev_coop==0)*inv.logit((-0.2574838)*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-1.214198)*GINI + (2.508148)*GINI*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-0.9749075)) + as.numeric(V==1 & node_rX$prev_coop==1)*inv.logit((- 0.6197254)*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-0.7480261)*GINI + (1.169674)*GINI*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (1.356784))
          } 
        #####manipulate cooperation rate ar round 1 depending on the degree! (keep the total coopertion rate at round 1 constant)
        #####make it so that the nodes with the top fractionCoop*100 percentile of degrees will 100% be a cooperator, but the average percentage of being a cooperator will be the same
        if(k==1){
          if(fractionCoop>0){
          node_rX$coop = apply(data.frame(ifelse(node_rX$prev_degree<=quantile(node_rX$prev_degree,fractionCoop),1,(node_rX$prob_coop*nrow(node_rX) - 1*table(node_rX$prev_degree<=quantile(node_rX$prev_degree,fractionCoop))["TRUE"])/table(node_rX$prev_degree<=quantile(node_rX$prev_degree,fractionCoop))["FALSE"])),
                               1,
                               function(x) {sample(1:0,1,prob=c(x,(1-x)))})
            } else if(fractionCoop==0) { 
              node_rX$coop = apply(data.frame(node_rX$prob_coop),1,function(x) {sample(1:0,1,prob=c(x,(1-x)))})
            }
        } else {
          node_rX$coop = apply(data.frame(node_rX$prob_coop),1,function(x) {sample(1:0,1,prob=c(x,(1-x)))})
        }
        if (k==1) {
          node_rX$initial_coop = node_rX$coop
          } else {
          node_rX$initial_coop = node_rX$initial_coop
          }
        node_rX$cost = (-50)*node_rX$coop*node_rX$prev_degree
        node_rX$n_coop_received = NA
        for (i in 1:(dim(node_rX)[1]))
          {
          node_rX[i,]$n_coop_received = sum(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) ==
          "alt_id"]],"coop"])
          }
        node_rX$benefit = 100*node_rX$n_coop_received
        node_rX$payoff = node_rX$cost + node_rX$benefit
        node_rX$wealth = node_rX$prev_wealth + node_rX$payoff
        node_rX$rel_rank = NA
        node_rX$local_rate_coop = NA
        for (i in 1:dim(node_rX)[1])
          {
          node_rX[i,]$rel_rank = rank1(na.omit(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in%
          c("ego_id","alt_id")]],"wealth"]))/length(na.omit(node_rX[node_rX$ego_id %in%
          node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX[i,]$local_rate_coop = mean(na.omit(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in%
          c("ego_id","alt_id")]],"coop"]))
          }
        node_rX$growth = as.numeric((node_rX$wealth/node_rX$prev_wealth) > 1)
        node_rX = node_rX[,c("ego_id","round","group","prev_degree","initial_wealth","initial_local_gini","initial_coop","coop","wealth","rel_rank","local_rate_coop","growth","everIsolated")] #Pruning the previous-round data (degree is not updating yet)
        
        #3-2: Rewiring phase
        # 30% of ties (unidirectional) are being rewired
        link_rX_1 = link_import #Importing data (bidirectioanl ego-alter [ego_id < alter_id])
        colnames(link_rX_1) = c("ego_id","alt_id","prev_connected")
        link_rX_1$challenge = sample(0:1,dim(link_rX_1)[1],replace=TRUE,prob=c(0.7,0.3)) # The bidirectional ties being rewired are selected (rewiring rate = 0.3).
        ego_node_data =
        node_rX[,c("ego_id","wealth","coop","prev_degree","initial_wealth","initial_local_gini","initial_coop","rel_rank","local_rate_coop","growth")]
        colnames(ego_node_data) =
        c("ego_id","ego_wealth","ego_coop","ego_prev_degree","ego_initial_wealth","ego_initial_local_gini","ego_initial_coop","ego_rel_rank","ego_local_rate_coop","ego_growth")
        alt_node_data =
        node_rX[,c("ego_id","wealth","coop","prev_degree","initial_wealth","initial_local_gini","initial_coop","rel_rank","local_rate_coop","growth")]
        colnames(alt_node_data) =
        c("alt_id","alt_wealth","alt_coop","alt_prev_degree","alt_initial_wealth","alt_initial_local_gini","alt_initial_coop","alt_rel_rank","alt_local_rate_coop","alt_growth")
        link_rX_2 = merge(x=link_rX_1,y=ego_node_data,all.x=TRUE,all.y=FALSE,by="ego_id")
        link_rX_3 = merge(x=link_rX_2,y=alt_node_data,all.x=TRUE,all.y=FALSE,by="alt_id")
        link_rX_3$choice = sample(c("ego","alt"),dim(link_rX_3)[1],replace=TRUE,prob=c(0.5,0.5)) #decision maker for breaking a link, which is a unilateral decision
        #ego_prob: probability of choosing to connect when challenged (asked)
        link_rX_3$ego_prob = inv.logit((0.5134401)*link_rX_3$prev_connected + (-0.852406)*link_rX_3$ego_coop + (2.96549)*link_rX_3$alt_coop + (-0.1808545))
        link_rX_3$alt_prob = inv.logit((0.5134401)*link_rX_3$prev_connected + (-0.852406)*link_rX_3$alt_coop + (2.96549)*link_rX_3$ego_coop + (-0.1808545))
        link_rX_3$prob_connect = ifelse(link_rX_3$prev_connected == 1, ifelse(link_rX_3$choice == "ego", link_rX_3$ego_prob,
        link_rX_3$alt_prob), link_rX_3$ego_prob*link_rX_3$alt_prob)
        link_rX_3$connect_update = apply(data.frame(link_rX_3$prob_connect),1, function(x) {sample(1:0,1,prob=c(x,(1-x)))})
        link_rX_3$connected = ifelse(link_rX_3$challenge==0,link_rX_3$prev_connected,link_rX_3$connect_update)
        link_rX = link_rX_3[,c("ego_id","alt_id","connected")] #pruning and data is updated
        #Reflect the degree and local gini coefficient into the node data
        link_rXc_ego = link_rX[link_rX$connected==1,]
        link_rXc_alt = link_rX[link_rX$connected==1,]
        colnames(link_rXc_alt) = c("alt_id","ego_id","connected")
        link_rXc = rbind(link_rXc_ego,link_rXc_alt)
        link_rXc = link_rXc[order(link_rXc$ego_id),]
        link_rXc$alternumber = NA
        link_rXc[1,]$alternumber = 1
        for (i in 1:(dim(link_rXc)[1]-1))
          {
            if (link_rXc[i,]$ego_id == link_rXc[i+1,]$ego_id)
            {
            link_rXc[i+1,]$alternumber = link_rXc[i,]$alternumber + 1
            }
            else
            {
            link_rXc[i+1,]$alternumber = 1
            }
            #print(i)
          }
        link_rXc2 = reshape(link_rXc, direction = "wide", idvar=c("ego_id","connected"), timevar="alternumber")
        link_rXc2$degree = apply(link_rXc2[,colnames(link_rXc2)[substr(colnames(link_rXc2),1,3) == "alt"]],1,function(x) {length(na.omit(x))})
        node_rX_final = merge(x=node_rX[,c("ego_id","round","group","initial_wealth","initial_local_gini","initial_coop","coop","wealth","growth","everIsolated")],y=link_rXc2,all.x=TRUE,all.y=FALSE,by="ego_id")
        node_rX_final[is.na(node_rX_final$degree)==1,"degree"] = 0
        node_rX_final$avg_env_wealth = NA
        node_rX_final$local_gini = NA #needs to be updated because the social network changes at the rewiring phase
        node_rX_final$local_rate_coop = NA
        node_rX_final$rel_rank = NA
        for (i in 1:dim(node_rX_final)[1])
          {
          node_rX_final[i,]$avg_env_wealth = mean(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$local_gini = gini(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$local_rate_coop = mean(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"coop"]))
          node_rX_final[i,]$rel_rank = rank1(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in%
          c("ego_id","alt_id")]],"wealth"]))/length(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$everIsolated = ifelse(node_rX_final[i,]$everIsolated==1,1,ifelse(node_rX_final[i,]$degree<=isolationDegree,1,0))
        }
        
        
        #Finalization of round X and Visualization
        #plot(graph.data.frame(link_rX[link_rX$connected==1,],directed=F)) #plot.igraph
        result[result$round==k,2:20] =
        c(length(node_rX_final$ego_id),length(node_rX_final[node_rX_final$group=="rich",]$ego_id),mean(node_rX_final$coop),mean(node_rX_final$degree),mean(node_rX_final$wealth),gini(node_rX_final$wealth),gmd(node_rX_final$wealth),mean(node_rX_final[node_rX_final$group=="rich",]$coop),mean(node_rX_final[node_rX_final$group=="rich",]$degree),mean(node_rX_final[node_rX_final$group=="rich",]$wealth),gini(node_rX_final[node_rX_final$group=="rich",]$wealth),gmd(node_rX_final[node_rX_final$group=="rich",]$wealth),mean(node_rX_final[node_rX_final$group=="poor",]$coop),mean(node_rX_final[node_rX_final$group=="poor",]$degree),mean(node_rX_final[node_rX_final$group=="poor",]$wealth),gini(node_rX_final[node_rX_final$group=="poor",]$wealth),gmd(node_rX_final[node_rX_final$group=="poor",]$wealth),
                                       as.numeric(ifelse(is.na(table(node_rX_final$degree<=isolationDegree)["TRUE"]),0,1)),
                                       as.numeric(sum(node_rX_final$everIsolated)/length(node_rX_final$ego_id)))
        #For the loop
        node_import = node_rX_final
        colnames(node_import)[colnames(node_import) %in%
        c("coop","wealth","growth","degree","avg_env_wealth","local_gini","local_rate_coop","rel_rank")] =
        c("prev_coop","prev_wealth","prev_growth","prev_degree","prev_avg_env_wealth","prev_local_gini","prev_local_rate_coop","prev_rel_rank")
        link_import = link_rX
        #print(paste0("Round ",k," is done."))
      }
      
      coopFrac[m] = fractionCoop
      avgCoop[m] = result[result$round==1,]$avg_coop
      percentIsolation[m] = max(result[result$round>=1,]$percentIsolation)
      isolation[m] = max(result[result$round>=1,]$isolation)
      percentIsolatedD[m] = prop.table(table(node_rX_final[node_rX_final$everIsolated==1,]$initial_coop))["0"]
    }
    
df.netIntLowDegree = rbind(df.netIntLowDegree,
                  data.frame(
                    coopFrac = coopFrac,
                    avgCoop = avgCoop,
                    percentIsolation = percentIsolation,
                    isolation = isolation,
                    percentIsolatedD = percentIsolatedD))

}

sum.netIntLowDegree <- data.frame(
  df.netIntLowDegree %>% 
    group_by(coopFrac) %>%
      summarise(
        mean.isolation = mean(isolation),
        ci.isolation   = 1.96 * sd(isolation)/sqrt(n()),
        mean.percentIsolation = mean(percentIsolation),
        ci.percentIsolation   = 1.96 * sd(percentIsolation)/sqrt(n()),
        mean.percentIsolatedD = mean(percentIsolatedD,na.rm=TRUE),
        ci.percentIsolatedD   = 1.96 * sd(percentIsolatedD,na.rm=TRUE)/sqrt(sum(isolation)),
        mean.avgCoop = mean(avgCoop,na.rm=TRUE),
        ci.avgCoop   = 1.96 * sd(avgCoop,na.rm=TRUE)/sqrt(n())
        )
  )

sum.netIntLowDegree

compare_means(percentIsolation ~ coopFrac, data=df.netIntLowDegree)
compare_means(avgCoop ~ coopFrac, data=df.netIntLowDegree)

g.netIntLowDegree = ggbarplot(data=df.netIntLowDegree, x="coopFrac", y="percentIsolation", add = "mean_se") +
  stat_compare_means(ref.group = "0", label = "p.signif", label.y = 0.028, method="t.test") +  
  labs(
    title = "Isolation when cooperators are assigned to low-degree nodes",
    x = "Proportion of low-degree nodes assigned to cooperators",
    y = "Propoption of ever-isolated individuals") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_cartesian(ylim=c(0,0.03))
g.netIntLowDegree
```



#Simulation 2
##Rate of cooperators is set constant
##All graphs start as Erdos-Renyi random newtorks
##Change where to place the cooperators in the network: 2. cooperators have high degrees
```{r simulation_C_high_degree}
#Define degrees of isolation
isolationDegree = 1

#number of iterations per arm
iterations = 500


df.netIntHighDegree = data.frame(
  coopFrac = NULL,
  avgCoop = NULL,
  percentIsolation = NULL,
  isolation = NULL,
  percentIsolatedD = NULL
)


for(frac in c(0,0.05,0.1,0.15,0.2)){
  #nodes in the top fractionCoop degrees will automatically be a cooperator
  fractionCoop = frac
  
    coopFrac = NULL
    avgCoop = NULL
    percentIsolation = NULL
    isolation = NULL
    percentIsolatedD = NULL
    for(m in c(1:iterations)){
      # Section 1. NOTES, packages, and Parameters
      #Importing library
      library(igraph) # for network graphing
      library(reldist) # for gini calculatio
      library(boot) # for inv.logit calculation
      #Two prefixed functions
      #rank
      rank1 = function(x) {rank(x,na.last=NA,ties.method="average")[1]} #a smaller value has a smaller rank.
      #gini mean difference (a.k.a. mean difference: please refer to https://stat.ethz.ch/pipermail/r-help/2003-April/032782.html)
      gmd = function(x) {
       x1 = na.omit(x)
       n = length(x1)
      tmp = 0
       for (i in 1:n) {
       for (j in 1:n) {
       tmp <- tmp + abs(x1[i]-x1[j])
       }
       }
      answer = tmp/(n*n)
       return(answer)
      }
      # List of manipulating parameters of experiments
      #L : number of round
      #V : Visible or not
      #A : Income of a rich-group subject
      #B : Income of a poor-group subject
      #R : Probability to be assigned to a rich group
      #I : Number of the same-parameter trial
      #Example
      L = 10
      V = 0
      A = 700
      B = 300
      R = 0.5
      I = 0
      # List of fixed parameters of experiments (assumptions)
      #Rewiring rate = 0.3
      #GINI coefficient (can be known by A or B)
      GINI = 0*as.numeric(A==500) + 0.2*as.numeric(A %in% c(700,850)) + 0.4*as.numeric(A ==1150)
      #Collecting data frame (final output data frame)
      result = data.frame(round=0:L,n_par=NA,n_A=NA,avg_coop=NA,avg_degree=NA,avg_wealth=NA,gini=NA,gmd=NA,avg_coop_A=NA,avg_degree_A=NA,avg_wealth_A=NA,gini_A=NA,gmd_A=NA,avg_coop_B=NA,avg_degree_B=NA,avg_wealth_B=NA,gini_B=NA,gmd_B=NA,isolation=NA,percentIsolation=NA)
      #_A is for a richer group and _B is for a poorer group
      
      
      
      #####################################################
      # Section 2: Round 0 (Agents and environments)
      #Node data generation
      N = 17 # median of the number of participants over rounds.
      node_r0 = data.frame(ego_id=1:N, round=0)
      node_r0$group = sample(c("rich","poor"),N,replace=TRUE,prob=c(R,1-R)) #R is defined as the probability to be assigned to the rich group
      node_r0$initial_wealth = ifelse(node_r0$group=="rich",A,B)
      #Link data generation
      ego_list = NULL
      for (i in 1:N) { ego_list = c(ego_list,rep(i,N)) }
      link_r0 = data.frame(ego_id=ego_list,alt_id=rep(1:N,N))
      link_r0 = link_r0[(link_r0$ego_id < link_r0$alt_id),] #The link was bidirectional, and thus the half and self are omitted.
      link_r0$connected = sample(0:1,dim(link_r0)[1],replace=TRUE,prob=c(0.7,0.3)) #Initial rewiring rate is fixed, 0.3
      link_r0c_ego = link_r0[link_r0$connected==1,]
      link_r0c_alt = link_r0[link_r0$connected==1,]
      colnames(link_r0c_alt) = c("alt_id","ego_id","connected")
      link_r0c = rbind(link_r0c_ego,link_r0c_alt) #this is bidirectional (double counted) for connected ties.
      link_r0c = link_r0c[order(link_r0c$ego_id),]
      link_r0c$alternumber = NA #putting the number for each alter in the same ego
      link_r0c[1,]$alternumber = 1
      for (i in 1:(dim(link_r0c)[1]-1))
        {if (link_r0c[i,]$ego_id == link_r0c[i+1,]$ego_id)
          {link_r0c[i+1,]$alternumber = link_r0c[i,]$alternumber + 1}
        else
          {link_r0c[i+1,]$alternumber = 1}
        #print(i)
        }
      link_r0c2 = reshape(link_r0c, direction = "wide", idvar=c("ego_id","connected"), timevar="alternumber")
      link_r0c2$initial_degree = apply(link_r0c2[,colnames(link_r0c2)[substr(colnames(link_r0c2),1,6) == "alt_id"]],1,function(x){length(na.omit(x))}) #Degree of each ego
      link_r0c2[is.na(link_r0c2$initial_degree)==1,"initial_degree"] = 0
      #Reflect the degree and initial local gini coefficient into the node data
      node_r0 = merge(x=node_r0,y=link_r0c2,all.x=TRUE,all.y=FALSE,by="ego_id")
      node_r0$initial_avg_env_wealth = NA
      node_r0$initial_local_gini = NA #local gini coefficient of the ego and connecting alters
      node_r0$initial_rel_rank = NA #local rank of ego among the ego and connecting alters (divided by the number of the go and connecting alters)
      for (i in 1:(dim(node_r0)[1])){
        node_r0[i,]$initial_avg_env_wealth = mean(na.omit(node_r0[node_r0$ego_id %in%
        node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6) %in% c("ego_id","alt_id")]],"initial_wealth"]))
        node_r0[i,]$initial_local_gini = gini(na.omit(node_r0[node_r0$ego_id %in% node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6)
        %in% c("ego_id","alt_id")]],"initial_wealth"]))
        node_r0[i,]$initial_rel_rank = rank1(na.omit(node_r0[node_r0$ego_id %in% node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6)
        %in% c("ego_id","alt_id")]],"initial_wealth"]))/length(na.omit(node_r0[node_r0$ego_id %in%
        node_r0[i,colnames(node_r0)[substr(colnames(node_r0),1,6) %in% c("ego_id","alt_id")]],"initial_wealth"]))
        }
      #Finalization of round 0 and Visualization
      #plot(graph.data.frame(link_r0[link_r0$connected==1,],directed=F)) #plot.igraph
      node_r0$everIsolated = 0
      result[result$round==0,2:20] = c(length(node_r0$ego_id),length(node_r0[node_r0$group=="rich",]$ego_id),NA,mean(node_r0$initial_degree),mean(node_r0$initial_wealth),gini(node_r0$initial_wealth),gmd(node_r0$initial_wealth),NA,mean(node_r0[node_r0$group=="rich",]$initial_degree),mean(node_r0[node_r0$group=="rich",]$initial_wealth),gini(node_r0[node_r0$group=="rich",]$initial_wealth),gmd(node_r0[node_r0$group=="rich",]$initial_wealth),NA,mean(node_r0[node_r0$group=="poor",]$initial_degree),mean(node_r0[node_r0$group=="poor",]$initial_wealth),gini(node_r0[node_r0$group=="poor",]$initial_wealth),gmd(node_r0[node_r0$group=="poor",]$initial_wealth),
                                       as.numeric(ifelse(is.na(table(node_r0$initial_degree<=isolationDegree)["TRUE"]),0,1)),
                                       as.numeric(sum(node_r0$everIsolated)/length(node_r0$ego_id)))
      
      #For the loop at the next round (for round 1, the initial one is the same as the previous [1 prior] one)
      node_import = node_r0
      node_import$initial_coop = NA
      node_import$prev_coop = NA
      node_import$prev_wealth = node_import$initial_wealth
      node_import$prev_degree = node_import$initial_degree
      node_import$prev_avg_env_wealth = node_import$initial_avg_env_wealth
      node_import$prev_local_gini = node_import$initial_local_gini
      node_import$prev_rel_rank = node_import$initial_rel_rank
      node_import$prev_local_rate_coop = NA
      link_import = link_r0
      
      
      
      #####################################################
      # Section 3: Rounds 1 to 10 or more (behaviors in simulation: the equation of cooperation is different at round 1 because of no history)
      #3-1: Cooperation phase
      for (k in 1:L)
      {
        node_rX = node_import #Importing data
        node_rX$round = node_rX$round + 1
        node_rX[is.na(node_rX$prev_degree)==1,"prev_degree"] = 0
        node_rX[is.na(node_rX$prev_local_rate_coop)==1,"prev_local_rate_coop"] = 0
        #Only this calculation needs to change from Round 1
        if (k==1) {
          node_rX$prob_coop = as.numeric(V==0)*inv.logit(0.9241803) + as.numeric(V==1)*inv.logit((-1.017021)*GINI + (0.8130213))
          } else {
          node_rX$prob_coop = as.numeric(V==0 & node_rX$prev_coop==0)*inv.logit(-1.039916) + as.numeric(V==0 & node_rX$prev_coop==1)*inv.logit(2.062023) + as.numeric(V==1 & node_rX$prev_coop==0)*inv.logit((-0.2574838)*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-1.214198)*GINI + (2.508148)*GINI*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-0.9749075)) + as.numeric(V==1 & node_rX$prev_coop==1)*inv.logit((- 0.6197254)*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (-0.7480261)*GINI + (1.169674)*GINI*as.numeric(node_rX$prev_avg_env_wealth - node_rX$prev_wealth > 0) + (1.356784))
          } 
        #####manipulate cooperation rate ar round 1 depending on the degree! (keep the total coopertion rate at round 1 constant)
        #####make it so that the nodes with the top fractionCoop*100 percentile of degrees will 100% be a cooperator, but the average percentage of being a cooperator will be the same
        if(k==1){
          if(fractionCoop>0){
          node_rX$coop = apply(data.frame(ifelse(node_rX$prev_degree>=quantile(node_rX$prev_degree,1-fractionCoop),1,(node_rX$prob_coop*nrow(node_rX) - 1*table(node_rX$prev_degree>=quantile(node_rX$prev_degree,1-fractionCoop))["TRUE"])/table(node_rX$prev_degree>=quantile(node_rX$prev_degree,1-fractionCoop))["FALSE"])),
                               1,
                               function(x) {sample(1:0,1,prob=c(x,(1-x)))})
            } else if(fractionCoop==0) { 
              node_rX$coop = apply(data.frame(node_rX$prob_coop),1,function(x) {sample(1:0,1,prob=c(x,(1-x)))})
            }
        } else {
          node_rX$coop = apply(data.frame(node_rX$prob_coop),1,function(x) {sample(1:0,1,prob=c(x,(1-x)))})
        }
        if (k==1) {
          node_rX$initial_coop = node_rX$coop
          } else {
          node_rX$initial_coop = node_rX$initial_coop
          }
        node_rX$cost = (-50)*node_rX$coop*node_rX$prev_degree
        node_rX$n_coop_received = NA
        for (i in 1:(dim(node_rX)[1]))
          {
          node_rX[i,]$n_coop_received = sum(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) ==
          "alt_id"]],"coop"])
          }
        node_rX$benefit = 100*node_rX$n_coop_received
        node_rX$payoff = node_rX$cost + node_rX$benefit
        node_rX$wealth = node_rX$prev_wealth + node_rX$payoff
        node_rX$rel_rank = NA
        node_rX$local_rate_coop = NA
        for (i in 1:dim(node_rX)[1])
          {
          node_rX[i,]$rel_rank = rank1(na.omit(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in%
          c("ego_id","alt_id")]],"wealth"]))/length(na.omit(node_rX[node_rX$ego_id %in%
          node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX[i,]$local_rate_coop = mean(na.omit(node_rX[node_rX$ego_id %in% node_rX[i,colnames(node_rX)[substr(colnames(node_rX),1,6) %in%
          c("ego_id","alt_id")]],"coop"]))
          }
        node_rX$growth = as.numeric((node_rX$wealth/node_rX$prev_wealth) > 1)
        node_rX = node_rX[,c("ego_id","round","group","prev_degree","initial_wealth","initial_local_gini","initial_coop","coop","wealth","rel_rank","local_rate_coop","growth","everIsolated")] #Pruning the previous-round data (degree is not updating yet)
        
        #3-2: Rewiring phase
        # 30% of ties (unidirectional) are being rewired
        link_rX_1 = link_import #Importing data (bidirectioanl ego-alter [ego_id < alter_id])
        colnames(link_rX_1) = c("ego_id","alt_id","prev_connected")
        link_rX_1$challenge = sample(0:1,dim(link_rX_1)[1],replace=TRUE,prob=c(0.7,0.3)) # The bidirectional ties being rewired are selected (rewiring rate = 0.3).
        ego_node_data =
        node_rX[,c("ego_id","wealth","coop","prev_degree","initial_wealth","initial_local_gini","initial_coop","rel_rank","local_rate_coop","growth")]
        colnames(ego_node_data) =
        c("ego_id","ego_wealth","ego_coop","ego_prev_degree","ego_initial_wealth","ego_initial_local_gini","ego_initial_coop","ego_rel_rank","ego_local_rate_coop","ego_growth")
        alt_node_data =
        node_rX[,c("ego_id","wealth","coop","prev_degree","initial_wealth","initial_local_gini","initial_coop","rel_rank","local_rate_coop","growth")]
        colnames(alt_node_data) =
        c("alt_id","alt_wealth","alt_coop","alt_prev_degree","alt_initial_wealth","alt_initial_local_gini","alt_initial_coop","alt_rel_rank","alt_local_rate_coop","alt_growth")
        link_rX_2 = merge(x=link_rX_1,y=ego_node_data,all.x=TRUE,all.y=FALSE,by="ego_id")
        link_rX_3 = merge(x=link_rX_2,y=alt_node_data,all.x=TRUE,all.y=FALSE,by="alt_id")
        link_rX_3$choice = sample(c("ego","alt"),dim(link_rX_3)[1],replace=TRUE,prob=c(0.5,0.5)) #decision maker for breaking a link, which is a unilateral decision
        #ego_prob: probability of choosing to connect when challenged (asked)
        link_rX_3$ego_prob = inv.logit((0.5134401)*link_rX_3$prev_connected + (-0.852406)*link_rX_3$ego_coop + (2.96549)*link_rX_3$alt_coop + (-0.1808545))
        link_rX_3$alt_prob = inv.logit((0.5134401)*link_rX_3$prev_connected + (-0.852406)*link_rX_3$alt_coop + (2.96549)*link_rX_3$ego_coop + (-0.1808545))
        link_rX_3$prob_connect = ifelse(link_rX_3$prev_connected == 1, ifelse(link_rX_3$choice == "ego", link_rX_3$ego_prob,
        link_rX_3$alt_prob), link_rX_3$ego_prob*link_rX_3$alt_prob)
        link_rX_3$connect_update = apply(data.frame(link_rX_3$prob_connect),1, function(x) {sample(1:0,1,prob=c(x,(1-x)))})
        link_rX_3$connected = ifelse(link_rX_3$challenge==0,link_rX_3$prev_connected,link_rX_3$connect_update)
        link_rX = link_rX_3[,c("ego_id","alt_id","connected")] #pruning and data is updated
        #Reflect the degree and local gini coefficient into the node data
        link_rXc_ego = link_rX[link_rX$connected==1,]
        link_rXc_alt = link_rX[link_rX$connected==1,]
        colnames(link_rXc_alt) = c("alt_id","ego_id","connected")
        link_rXc = rbind(link_rXc_ego,link_rXc_alt)
        link_rXc = link_rXc[order(link_rXc$ego_id),]
        link_rXc$alternumber = NA
        link_rXc[1,]$alternumber = 1
        for (i in 1:(dim(link_rXc)[1]-1))
          {
            if (link_rXc[i,]$ego_id == link_rXc[i+1,]$ego_id)
            {
            link_rXc[i+1,]$alternumber = link_rXc[i,]$alternumber + 1
            }
            else
            {
            link_rXc[i+1,]$alternumber = 1
            }
            #print(i)
          }
        link_rXc2 = reshape(link_rXc, direction = "wide", idvar=c("ego_id","connected"), timevar="alternumber")
        link_rXc2$degree = apply(link_rXc2[,colnames(link_rXc2)[substr(colnames(link_rXc2),1,3) == "alt"]],1,function(x) {length(na.omit(x))})
        node_rX_final = merge(x=node_rX[,c("ego_id","round","group","initial_wealth","initial_local_gini","initial_coop","coop","wealth","growth","everIsolated")],y=link_rXc2,all.x=TRUE,all.y=FALSE,by="ego_id")
        node_rX_final[is.na(node_rX_final$degree)==1,"degree"] = 0
        node_rX_final$avg_env_wealth = NA
        node_rX_final$local_gini = NA #needs to be updated because the social network changes at the rewiring phase
        node_rX_final$local_rate_coop = NA
        node_rX_final$rel_rank = NA
        for (i in 1:dim(node_rX_final)[1])
          {
          node_rX_final[i,]$avg_env_wealth = mean(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$local_gini = gini(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$local_rate_coop = mean(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"coop"]))
          node_rX_final[i,]$rel_rank = rank1(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in%
          c("ego_id","alt_id")]],"wealth"]))/length(na.omit(node_rX_final[node_rX_final$ego_id %in%
          node_rX_final[i,colnames(node_rX_final)[substr(colnames(node_rX_final),1,6) %in% c("ego_id","alt_id")]],"wealth"]))
          node_rX_final[i,]$everIsolated = ifelse(node_rX_final[i,]$everIsolated==1,1,ifelse(node_rX_final[i,]$degree<=isolationDegree,1,0))
        }
        
        
        #Finalization of round X and Visualization
        #plot(graph.data.frame(link_rX[link_rX$connected==1,],directed=F)) #plot.igraph
        result[result$round==k,2:20] =
        c(length(node_rX_final$ego_id),length(node_rX_final[node_rX_final$group=="rich",]$ego_id),mean(node_rX_final$coop),mean(node_rX_final$degree),mean(node_rX_final$wealth),gini(node_rX_final$wealth),gmd(node_rX_final$wealth),mean(node_rX_final[node_rX_final$group=="rich",]$coop),mean(node_rX_final[node_rX_final$group=="rich",]$degree),mean(node_rX_final[node_rX_final$group=="rich",]$wealth),gini(node_rX_final[node_rX_final$group=="rich",]$wealth),gmd(node_rX_final[node_rX_final$group=="rich",]$wealth),mean(node_rX_final[node_rX_final$group=="poor",]$coop),mean(node_rX_final[node_rX_final$group=="poor",]$degree),mean(node_rX_final[node_rX_final$group=="poor",]$wealth),gini(node_rX_final[node_rX_final$group=="poor",]$wealth),gmd(node_rX_final[node_rX_final$group=="poor",]$wealth),
                                       as.numeric(ifelse(is.na(table(node_rX_final$degree<=isolationDegree)["TRUE"]),0,1)),
                                       as.numeric(sum(node_rX_final$everIsolated)/length(node_rX_final$ego_id)))
        #For the loop
        node_import = node_rX_final
        colnames(node_import)[colnames(node_import) %in%
        c("coop","wealth","growth","degree","avg_env_wealth","local_gini","local_rate_coop","rel_rank")] =
        c("prev_coop","prev_wealth","prev_growth","prev_degree","prev_avg_env_wealth","prev_local_gini","prev_local_rate_coop","prev_rel_rank")
        link_import = link_rX
        #print(paste0("Round ",k," is done."))
      }
      
      coopFrac[m] = fractionCoop
      avgCoop[m] = result[result$round==1,]$avg_coop
      percentIsolation[m] = max(result[result$round>=1,]$percentIsolation)
      isolation[m] = max(result[result$round>=1,]$isolation)
      percentIsolatedD[m] = prop.table(table(node_rX_final[node_rX_final$everIsolated==1,]$initial_coop))["0"]
    }
    
df.netIntHighDegree = rbind(df.netIntHighDegree,
                  data.frame(
                    coopFrac = coopFrac,
                    avgCoop = avgCoop,
                    percentIsolation = percentIsolation,
                    isolation = isolation,
                    percentIsolatedD = percentIsolatedD))

}

sum.netIntHighDegree <- data.frame(
  df.netIntHighDegree %>% 
    group_by(coopFrac) %>%
      summarise(
        mean.isolation = mean(isolation),
        ci.isolation   = 1.96 * sd(isolation)/sqrt(n()),
        mean.percentIsolation = mean(percentIsolation),
        ci.percentIsolation   = 1.96 * sd(percentIsolation)/sqrt(n()),
        mean.percentIsolatedD = mean(percentIsolatedD,na.rm=TRUE),
        ci.percentIsolatedD   = 1.96 * sd(percentIsolatedD,na.rm=TRUE)/sqrt(sum(isolation)),
        mean.avgCoop = mean(avgCoop,na.rm=TRUE),
        ci.avgCoop   = 1.96 * sd(avgCoop,na.rm=TRUE)/sqrt(n())
        )
  )

sum.netIntHighDegree

compare_means(percentIsolation ~ coopFrac, data=df.netIntHighDegree)
compare_means(avgCoop ~ coopFrac, data=df.netIntHighDegree)

g.netIntHighDegree = ggbarplot(data=df.netIntHighDegree, x="coopFrac", y="percentIsolation", add = "mean_se") +
  stat_compare_means(ref.group = "0", label = "p.signif", label.y = 0.028, method="t.test") +  
  labs(
    title = "Isolation when cooperators are assigned to high-degree nodes",
    x = "Proportion of high-degree nodes assigned to cooperators",
    y = "Propoption of ever-isolated individuals") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_cartesian(ylim=c(0,0.03))
g.netIntHighDegree
```



###Assigning cooperators to low-degree nodes could prevent isolation
###But assigning cooperators to high-degree nodes has a null effect on isolation
###Isolated individuals are mostly defectors
