---
title: "SNA isolation"
author: "Ryunosuke Goto"
date: "10/2/2022"
output: html_document
---

```{r setup, include=FALSE}

#to run RMD
#library(rmarkdown)
#rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
#rmarkdown::render(paste(rootdir,"rmd/sna_isolation.Rmd", sep="/"))

knitr::opts_chunk$set(warning=FALSE, message=FALSE, echo=TRUE)

library(dplyr)
library(tidyr)
library(ggplot2)
library(arsenal)
library(gridExtra)
library(ggpubr)
library(cowplot)
library(grid)
library(MASS)
library(knitr)
library(igraph)
library(data.table)
library(Rtsne)
library(caret)
library(pdp)
library(dtwclust)
library(randomForest)

rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]

source(paste(rootdir,"R/degree.R",sep="/"))

options(timeout=2000)
sampleList <- degree(redo=TRUE) #set redo=TRUE to update
sample = sampleList[[1]]
ldata = sampleList[[2]]
```


##Clustering
```{r clustering, include=FALSE, eval=FALSE, cache=FALSE, echo=FALSE, results="hide", fig.width=8, fig.height=8}
#####Dynamic time warping (time series clustering)#####
#https://rstudio-pubs-static.s3.amazonaws.com/474160_0761428e8683401e941a92a4177254a4.html
#here, we are using Dynamic Time Warping Barycenter Averaging (DBA), useful to extract the movement/shape
#https://www.kaggle.com/code/izzettunc/introduction-to-time-series-clustering/notebook 
library(TSclust)
library(dtwclust)
sample.clust = sample[c("degree.0","degree.1",
                        "degree.2","degree.3",
                        "degree.4","degree.5",
                        "degree.6","degree.7",
                        "degree.8","degree.9","degree.10")]
#use complete cases only
sample.clust = sample.clust[complete.cases(sample.clust),]

cluster.eval <- tsclust(sample.clust, k = 2L:10L,
                   type="partitional",
                   distance = "dtw", centroid = "dba",
                   seed = 10, trace = TRUE)

cluster.eval <- data.frame(sapply(cluster.eval,cvi))
colnames(cluster.eval) <- c(2:10)
```

```{r evaluating_clusters, include=FALSE, eval=FALSE}
#Silhouette (Sil), score function (SF), Calinski-Harabasz index (CH), Dunn index (D)
#the local maximum is considered the appropriate number of clusters
cluster.eval[c("Sil","SF","CH","D"),]

#Davies-Bouldin index (DB), modified Davies-Bouldin index (DBstar), COP index (COP)
#the local minimum is considered the appropriate number of clusters
cluster.eval[c("DB","DBstar","COP"),]
```

```{r clustering_results, include=FALSE, eval=FALSE, cache=FALSE, echo=FALSE, results="hide", fig.width=8, fig.height=8}
#Based on the above evaluations, 
#Six clusters is determined to be the appropriate number of clusters
sample.clust = sample[c("degree.0","degree.1",
                        "degree.2","degree.3",
                        "degree.4","degree.5",
                        "degree.6","degree.7",
                        "degree.8","degree.9","degree.10")]

#use complete cases only
sample.clust = sample.clust[complete.cases(sample.clust),]
cluster <- tsclust(sample.clust, k = 6L,
                   type="partitional",
                   distance = "dtw", centroid = "dba",
                   seed = 10, trace = TRUE)

```

```{r building_sample, cache=FALSE, echo=FALSE, results="hide", fig.width=8, fig.height=8}
sample.clust2 = sample[c("degree.0","degree.1",
                        "degree.2","degree.3",
                        "degree.4","degree.5",
                        "degree.6","degree.7",
                        "degree.8","degree.9","degree.10")]

clust = cbind(
  sample[complete.cases(sample.clust2),], 
  cluster = cluster@cluster
)

#reorder
clust = clust[c("ID","visibleWealth","inequality","gini","wealth","initScore","gameID","vertex",
                "degree.0","degree.1","degree.2","degree.3","degree.4","degree.5","degree.6","degree.7","degree.8","degree.9","degree.10",
                "coefLocal.0","coefLocal.1","coefLocal.2","coefLocal.3","coefLocal.4","coefLocal.5","coefLocal.6","coefLocal.7","coefLocal.8","coefLocal.9","coefLocal.10",
                "coefGlobal.0","coefGlobal.1","coefGlobal.2","coefGlobal.3","coefGlobal.4","coefGlobal.5","coefGlobal.6","coefGlobal.7","coefGlobal.8","coefGlobal.9","coefGlobal.10",
                "alterPrevWealth.0","alterPrevWealth.1","alterPrevWealth.2","alterPrevWealth.3","alterPrevWealth.4","alterPrevWealth.5","alterPrevWealth.6","alterPrevWealth.7","alterPrevWealth.8","alterPrevWealth.9","alterPrevWealth.10",
                "egoPrevWealth.0","egoPrevWealth.1","egoPrevWealth.2","egoPrevWealth.3","egoPrevWealth.4","egoPrevWealth.5","egoPrevWealth.6","egoPrevWealth.7","egoPrevWealth.8","egoPrevWealth.9","egoPrevWealth.10",
                "wealthDiff.0","wealthDiff.1","wealthDiff.2","wealthDiff.3","wealthDiff.4","wealthDiff.5","wealthDiff.6","wealthDiff.7","wealthDiff.8","wealthDiff.9","wealthDiff.10",
                "linksMadeByEgo.0","linksMadeByEgo.1","linksMadeByEgo.2","linksMadeByEgo.3","linksMadeByEgo.4","linksMadeByEgo.5","linksMadeByEgo.6","linksMadeByEgo.7","linksMadeByEgo.8","linksMadeByEgo.9","linksMadeByEgo.10",
                "linksNotMadeByEgo.0","linksNotMadeByEgo.1","linksNotMadeByEgo.2","linksNotMadeByEgo.3","linksNotMadeByEgo.4","linksNotMadeByEgo.5","linksNotMadeByEgo.6","linksNotMadeByEgo.7","linksNotMadeByEgo.8","linksNotMadeByEgo.9","linksNotMadeByEgo.10",
                "linksBrokenByEgo.0", "linksBrokenByEgo.1", "linksBrokenByEgo.2", "linksBrokenByEgo.3", "linksBrokenByEgo.4","linksBrokenByEgo.5", "linksBrokenByEgo.6", "linksBrokenByEgo.7", "linksBrokenByEgo.8", "linksBrokenByEgo.9", "linksBrokenByEgo.10",  
                "linksNotBrokenByEgo.0","linksNotBrokenByEgo.1","linksNotBrokenByEgo.2","linksNotBrokenByEgo.3","linksNotBrokenByEgo.4","linksNotBrokenByEgo.5","linksNotBrokenByEgo.6","linksNotBrokenByEgo.7","linksNotBrokenByEgo.8","linksNotBrokenByEgo.9","linksNotBrokenByEgo.10",
                "linksMadeByAlter.0","linksMadeByAlter.1", "linksMadeByAlter.2", "linksMadeByAlter.3", "linksMadeByAlter.4", "linksMadeByAlter.5", "linksMadeByAlter.6","linksMadeByAlter.7", "linksMadeByAlter.8", "linksMadeByAlter.9", "linksMadeByAlter.10",
                "linksNotMadeByAlter.0","linksNotMadeByAlter.1","linksNotMadeByAlter.2","linksNotMadeByAlter.3","linksNotMadeByAlter.4","linksNotMadeByAlter.5","linksNotMadeByAlter.6","linksNotMadeByAlter.7","linksNotMadeByAlter.8","linksNotMadeByAlter.9","linksNotMadeByAlter.10",
                "linksBrokenByAlter.0", "linksBrokenByAlter.1", "linksBrokenByAlter.2","linksBrokenByAlter.3", "linksBrokenByAlter.4", "linksBrokenByAlter.5", "linksBrokenByAlter.6", "linksBrokenByAlter.7", "linksBrokenByAlter.8","linksBrokenByAlter.9", "linksBrokenByAlter.10",
                "linksNotBrokenByAlter.0","linksNotBrokenByAlter.1","linksNotBrokenByAlter.2","linksNotBrokenByAlter.3","linksNotBrokenByAlter.4","linksNotBrokenByAlter.5","linksNotBrokenByAlter.6","linksNotBrokenByAlter.7","linksNotBrokenByAlter.8","linksNotBrokenByAlter.9" ,"linksNotBrokenByAlter.10",
                "alterBehavior.0", "alterBehavior.1", "alterBehavior.2", "alterBehavior.3", "alterBehavior.4","alterBehavior.5", "alterBehavior.6", "alterBehavior.7", "alterBehavior.8", "alterBehavior.9", "alterBehavior.10", 
                "behavior.0","behavior.1","behavior.2","behavior.3","behavior.4","behavior.5","behavior.6","behavior.7","behavior.8","behavior.9","behavior.10",     
                "cluster" )]


#####investigate clusters######
#convert to long format
setDT(clust)
clust.res<-NULL
clust.res = data.table::melt(clust,
     measure = patterns('degree','coefLocal','coefGlobal','alterPrevWealth','egoPrevWealth','wealthDiff','linksMadeByEgo','linksNotMadeByEgo','linksBrokenByEgo','linksNotBrokenByEgo',
                  'linksMadeByAlter','linksNotMadeByAlter','linksBrokenByAlter','linksNotBrokenByAlter','alterBehavior','behavior'),
     variable.name = 'round', 
     value.name = c('degree','coefLocal','coefGlobal','alterPrevWealth','egoPrevWealth','wealthDiff','linksMadeByEgo','linksNotMadeByEgo','linksBrokenByEgo','linksNotBrokenByEgo','linksMadeByAlter','linksNotMadeByAlter','linksBrokenByAlter','linksNotBrokenByAlter','alterBehavior','behavior'))
clust.res = as.data.frame(clust.res)

clust.res$round <- factor(as.numeric(clust.res$round)-1)
clust.res$cluster <- factor(clust.res$cluster)
clust.res$degree = as.numeric(clust.res$degree)
clust.res$linksMadeByEgo = as.numeric(clust.res$linksMadeByEgo)
clust.res$linksNotMadeByEgo = as.numeric(clust.res$linksNotMadeByEgo)
clust.res$linksBrokenByEgo = as.numeric(clust.res$linksBrokenByEgo)
clust.res$linksNotBrokenByEgo = as.numeric(clust.res$linksNotBrokenByEgo)
clust.res$linksMadeByAlter = as.numeric(clust.res$linksMadeByAlter)
clust.res$linksNotMadeByAlter = as.numeric(clust.res$linksNotMadeByAlter)
clust.res$linksBrokenByAlter = as.numeric(clust.res$linksBrokenByAlter)
clust.res$linksNotBrokenByAlter = as.numeric(clust.res$linksNotBrokenByAlter)
clust.res$behavior = factor(clust.res$behavior)
clust.res$alterBehavior = as.numeric(clust.res$alterBehavior)

clust.res = clust.res[c("ID","cluster","round","degree","coefLocal","coefGlobal",'alterPrevWealth','egoPrevWealth','wealthDiff',
                        "linksMadeByEgo","linksNotMadeByEgo","linksBrokenByEgo","linksNotBrokenByEgo",
                        "linksMadeByAlter","linksNotMadeByAlter","linksBrokenByAlter","linksNotBrokenByAlter",
                        "behavior","alterBehavior"
                        )]

clust = as.data.frame(clust)

```

```{r tsne, include=FALSE, eval=FALSE, cache=FALSE, echo=FALSE, results="hide", fig.width=8, fig.height=8}

sample.tsne = sample.clust[c("degree.0","degree.1",
                       "degree.2","degree.3",
                       "degree.4","degree.5",
                       "degree.6","degree.7",
                       "degree.8","degree.9","degree.10")]

colors = rainbow(length(unique(clust$cluster)))
names(colors) = unique(clust$cluster)
set.seed(10)
tsne = Rtsne(sample.tsne, dims = 2, perplexity=30, verbose=TRUE, max_iter = 500, check_duplicates = FALSE)

g <- ggplot(data.frame(tsne$Y),aes(x=tsne$Y[,1],y=tsne$Y[,2],color = as.factor(clust$cluster)))+
  geom_point() +
  #ggtitle("Five-cluster model") +
  xlab("tSNE dimension 1") +
  ylab("tSNE dimension 2") +
  scale_color_discrete(name  ="Cluster") + 
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) 

g

```

```{r investigate_clusters, cache=FALSE, echo=FALSE, results="hide", fig.width=8, fig.height=8}

#plot each cluster and the time series that belong to each cluster
plot(cluster, type = "sc")

#plot means and CIs
sum_clust <- clust.res %>% 
  group_by(round, cluster) %>%
  summarise(mean = mean(degree),
            ci   = 1.96 * sd(degree)/sqrt(n()))
pd <- position_dodge(width = 0.1)
sum_clust %>%
  ggplot(aes(x = round, y = mean, group = cluster)) +
  geom_line(aes(color = cluster), position = pd) +
  geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci, color=cluster),
                width = .1, position = pd) +
  theme_bw() +
  geom_point(size = 4, position = pd, aes(color=cluster)) +
  labs(
    title = "Trajectories of degrees",
    x = "Round",
    y = "Degree",
    color = NULL,
    linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5))

```


```{r cluster_characteristics, results="asis", include=FALSE, echo=FALSE}
#characteristics of each cluster
table.clust <- tableby(cluster ~ ., 
                  data = subset(clust, select = -c(ID,gameID,degree.0,degree.1,degree.2,degree.3,degree.4,degree.5,degree.6,degree.7,degree.8,degree.9,degree.10)), 
                  numeric.test="kwt", cat.test="chisq",
                  digits.p=3, digits.pct=1, digits=2)
res.clust = summary(table.clust, title = "Characteristics of each cluster")
res.clust

#Links made or broken during each round for each cluster: pie charts
#About 30% of possible links are chosen in each round, and for each link the participant(s) choose to make, break, not make, or not break the link
#Decisions made by ego
df.piechart.ego = aggregate(cbind(linksMadeByEgo,linksNotMadeByEgo,linksBrokenByEgo,linksNotBrokenByEgo) ~ cluster + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.ego <- df.piechart.ego %>% 
      gather(link, count, linksMadeByEgo:linksNotBrokenByEgo)
ggplot(data=df.piechart.ego, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(cluster~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Cluster", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 

#Decisions made by alter
df.piechart.alter = aggregate(cbind(linksMadeByAlter,linksNotMadeByAlter,linksBrokenByAlter,linksNotBrokenByAlter) ~ cluster + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.alter <- df.piechart.alter %>% 
      gather(link, count, linksMadeByAlter:linksNotBrokenByAlter)
ggplot(data=df.piechart.alter, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(cluster~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Cluster", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 


```

```{r isolation_cluster, results="asis", include=FALSE, echo=FALSE}
#Define isolation cluster
isolationCluster = 4
clust$isolationCluster = ifelse(clust$cluster==isolationCluster,1,0)
clust.res$isolationCluster = ifelse(clust.res$cluster==isolationCluster,1,0)


#characteristics of isolation cluster compared to others
table.clust <- tableby(isolationCluster ~ ., 
                  data = subset(clust, select = -c(ID,gameID,degree.0,degree.1,degree.2,degree.3,degree.4,degree.5,degree.6,degree.7,degree.8,degree.9,degree.10)), 
                  numeric.test="kwt", cat.test="chisq",
                  digits.p=3, digits.pct=1, digits=2)
res.clust = summary(table.clust, title = "Characteristics of isolation cluster compared to others")
res.clust


#Links made or broken during each round for isolation cluster vs others: pie charts
#About 30% of possible links are chosen in each round, and for each link the participant(s) choose to make, break, not make, or not break the link
#Decisions made by ego
df.piechart.ego = aggregate(cbind(linksMadeByEgo,linksNotMadeByEgo,linksBrokenByEgo,linksNotBrokenByEgo) ~ isolationCluster + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.ego <- df.piechart.ego %>% 
      gather(link, count, linksMadeByEgo:linksNotBrokenByEgo)
ggplot(data=df.piechart.ego, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(isolationCluster~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Isolation cluster", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 

#Decisions made by alter
df.piechart.alter = aggregate(cbind(linksMadeByAlter,linksNotMadeByAlter,linksBrokenByAlter,linksNotBrokenByAlter) ~ isolationCluster + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.alter <- df.piechart.alter %>% 
      gather(link, count, linksMadeByAlter:linksNotBrokenByAlter)
ggplot(data=df.piechart.alter, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(isolationCluster~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Isolation cluster", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 

```

#Histogram of degrees
```{r histogram, echo=FALSE}
hist(clust.res$degree, breaks = seq(from=min(clust.res$degree)-1,to=max(clust.res$degree),by = 1))
summary(clust.res$degree)
mean(clust.res$degree) + 2*sd(clust.res$degree)
mean(clust.res$degree) - 2*sd(clust.res$degree)
unique(clust.res[clust.res$degree==0,]$ID)
```


```{r isolation_characteristics, results="asis", include=FALSE, echo=FALSE}
clust$isolated = ifelse(clust$degree.1<=2 | clust$degree.2<=2 | clust$degree.3<=2 | clust$degree.4<=2 | clust$degree.5<=2|
                        clust$degree.6<=2 | clust$degree.7<=2 | clust$degree.8<=2 | clust$degree.9<=2 | clust$degree.10<=2,
                        1,0)
clust.res = merge(clust.res,clust[c("ID","isolated")],by="ID",all.x=TRUE)


#characteristics of isolated individuals compared to others
table.clust <- tableby(isolated ~ ., 
                  data = subset(clust, select = -c(ID,gameID,degree.0,degree.1,degree.2,degree.3,degree.4,degree.5,degree.6,degree.7,degree.8,degree.9,degree.10)), 
                  numeric.test="kwt", cat.test="chisq",
                  digits.p=3, digits.pct=1, digits=2)
res.clust = summary(table.clust, title = "Characteristics of individuals who end up in isolation, defined as degree<=2 in round 1 or later")
res.clust

#Links made or broken during each round for isolation cluster vs others: pie charts
#About 30% of possible links are chosen in each round, and for each link the participant(s) choose to make, break, not make, or not break the link
#Decisions made by ego
df.piechart.ego = aggregate(cbind(linksMadeByEgo,linksNotMadeByEgo,linksBrokenByEgo,linksNotBrokenByEgo) ~ isolated + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.ego <- df.piechart.ego %>% 
      gather(link, count, linksMadeByEgo:linksNotBrokenByEgo)
ggplot(data=df.piechart.ego, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(isolated~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Isolated or not", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 

#Decisions made by alter
df.piechart.alter = aggregate(cbind(linksMadeByAlter,linksNotMadeByAlter,linksBrokenByAlter,linksNotBrokenByAlter) ~ isolated + round, data=clust.res, FUN=sum, na.rm=TRUE)

df.piechart.alter <- df.piechart.alter %>% 
      gather(link, count, linksMadeByAlter:linksNotBrokenByAlter)
ggplot(data=df.piechart.alter, aes(x="", y=count, fill=link))+
  geom_bar(stat="identity", width=1, color="white", position = "fill") + 
  coord_polar("y", start = 0) +
  theme_bw() +
  facet_grid(isolated~round) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid  = element_blank()) +
  labs(title="Types of links per round", x="Isolated or not", y="Round") + 
  theme(plot.title = element_text(hjust = 0.5)) 


```


#Trajectory analysis
```{r trajectory_analysis}
#for each ID, find the minimum round (1 to 10) for which degree is 0
sample.i = clust.res[clust.res$degree<=2 & clust.res$round!=0,]
sample.i$round = as.numeric(sample.i$round) - 1
isolationRound <- aggregate(round ~ ID, data = sample.i, FUN = min, na.rm = TRUE)
colnames(isolationRound)[c(1:2)] = c("ID","roundZero")

#subtract the minimum round for which degree is 0 to obtain rounds to isolation
sample.traj = merge(clust.res[clust.res$round!=0,], isolationRound, by="ID", all.x=TRUE)
sample.traj$round = as.numeric(sample.traj$round) - 1
sample.traj$roundToIsolation = sample.traj$round - sample.traj$roundZero

#remove all "positive" rounds
sample.traj = subset(sample.traj, sample.traj$roundToIsolation<=0)


#trajectories
sum_traj <- sample.traj %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(degree, na.rm = TRUE),
            ci   = 1.96 * sd(degree, na.rm = TRUE)/sqrt(n()))
sum_traj %>%
  ggplot(aes(x = roundToIsolation, y = mean)) +
  geom_line(aes()) +
  geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci),
                width = .1) +
  theme_bw() +
  geom_point(size = 4) +
  labs(
    title = "Trajectories of degrees",
    x = "Round to isolation",
    y = "Degree",
    color = NULL,
    linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5))

```

#Comparison of degree trajectory and other variables
```{r degree_trajectory}
#Plot the degree trajectory (rounds to isolation) and another variable on the same graph
sample.cc = sample.traj

sum_traj <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean.degree = mean(degree),
            ci.degree   = 1.96 * sd(degree)/sqrt(n()))

sum_coef <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(coefLocal, na.rm=TRUE),
            ci   = 1.96 * sd(coefLocal, na.rm=TRUE)/sqrt(n()))

sum_alterPrevWealth <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(alterPrevWealth, na.rm=TRUE),
            ci   = 1.96 * sd(alterPrevWealth, na.rm=TRUE)/sqrt(n()))

sum_egoPrevWealth <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(egoPrevWealth, na.rm=TRUE),
            ci   = 1.96 * sd(egoPrevWealth, na.rm=TRUE)/sqrt(n()))

sum_wealthDiff <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(wealthDiff, na.rm=TRUE),
            ci   = 1.96 * sd(wealthDiff, na.rm=TRUE)/sqrt(n()))

sum_alterBehavior <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(alterBehavior, na.rm=TRUE),
            ci   = 1.96 * sd(alterBehavior, na.rm=TRUE)/sqrt(n()))

sample.cc <- sample.cc %>%
  mutate(behavior = 
           case_when(
             behavior=="C" ~ 1,
             behavior=="D" ~ 0
           ))

sum_behavior <- sample.cc %>% 
  group_by(roundToIsolation) %>%
  summarise(mean = mean(behavior, na.rm=TRUE),
            ci   = 1.96 * sd(behavior, na.rm=TRUE)/sqrt(n()))






cc.compare = merge(data.frame(sum_traj),data.frame(sum_wealthDiff),by="roundToIsolation")

scale=100

g.compare = ggplot(data=cc.compare, aes(x=roundToIsolation,y=mean.degree)) +
  geom_line(aes(color="Degree")) +
  geom_errorbar(aes(x = roundToIsolation, ymin = mean.degree - ci.degree, ymax = mean.degree + ci.degree, color="Degree"),width = .1) +
  geom_point(aes(x = roundToIsolation, y=mean.degree, color="Degree"),size = 4) +
  geom_line(aes(y = mean/scale, color="Average wealth difference in previous round")) +
  geom_errorbar(aes(x = roundToIsolation, ymin = mean/scale - ci/scale, ymax = mean/scale + ci/scale, color="Average wealth difference in previous round"),width = .1) +
  geom_point(aes(x = roundToIsolation, y=mean/scale, color="Average wealth difference in previous round"),size = 4) +
  scale_y_continuous(
    # Features of the first axis
    name = "Degree",
    # Add a second axis and specify its features
    sec.axis = sec_axis(~.*scale, name="Average wealth difference in previous round")) +
  labs(
    title = "Trajectories of degrees and wealth difference",
    x = "Round to isolation",
    y = "Degree",
    color = "") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("orange2", "gray30"))

g.compare
```










#Does inequality cause isolation?
```{r ind_level_comparison}
###does initial behavior predict whether someone will be ever isolated?
sample.reg = clust
sample.reg$isolated = ifelse(sample.reg$degree.1<=2 | sample.reg$degree.2<=2 | sample.reg$degree.3<=2 | sample.reg$degree.4<=2 | sample.reg$degree.5<=2|
                        sample.reg$degree.6<=2 | sample.reg$degree.7<=2 | sample.reg$degree.8<=2 | sample.reg$degree.9<=2 | sample.reg$degree.10<=2,
                        1,0)
sample.reg$inequality = relevel(factor(sample.reg$inequality),ref="none")

#inequality
reg.everIsolated.inequality = miceadds::glm.cluster(isolated ~ inequality*visibleWealth, 
      data = sample.reg, 
      cluster = "gameID",
      family = binomial(link = "logit"))
alpha <- 0.05
x.everIsolated.inequality <- summary(reg.everIsolated.inequality)
y.everIsolated.inequality <- confint(reg.everIsolated.inequality, level=1-alpha)
coef.everIsolated.inequality <- x.everIsolated.inequality[,1]
LowerCL.everIsolated.inequality <- y.everIsolated.inequality[,1]
UpperCL.everIsolated.inequality <- y.everIsolated.inequality[,2]
p.everIsolated.inequality <-x.everIsolated.inequality[,4]
#odds ratio
z.everIsolated.inequality <- rbind(
  cbind(exp(coef.everIsolated.inequality["inequalityhigh"]), exp(LowerCL.everIsolated.inequality["inequalityhigh"]), exp(UpperCL.everIsolated.inequality["inequalityhigh"]), p.everIsolated.inequality["inequalityhigh"]),
  cbind(exp(coef.everIsolated.inequality["inequalitylow"]), exp(LowerCL.everIsolated.inequality["inequalitylow"]), exp(UpperCL.everIsolated.inequality["inequalitylow"]), p.everIsolated.inequality["inequalitylow"]),
  cbind(exp(coef.everIsolated.inequality["visibleWealth"]), exp(LowerCL.everIsolated.inequality["visibleWealth"]), exp(UpperCL.everIsolated.inequality["visibleWealth"]), p.everIsolated.inequality["visibleWealth"]),
  cbind(exp(coef.everIsolated.inequality["inequalityhigh:visibleWealth"]), exp(LowerCL.everIsolated.inequality["inequalityhigh:visibleWealth"]), exp(UpperCL.everIsolated.inequality["inequalityhigh:visibleWealth"]), p.everIsolated.inequality["inequalityhigh:visibleWealth"]),
  cbind(exp(coef.everIsolated.inequality["inequalitylow:visibleWealth"]), exp(LowerCL.everIsolated.inequality["inequalitylow:visibleWealth"]), exp(UpperCL.everIsolated.inequality["inequalitylow:visibleWealth"]), p.everIsolated.inequality["inequalitylow:visibleWealth"])
)
z.everIsolated.inequality = data.frame(z.everIsolated.inequality)
names(z.everIsolated.inequality) = c("OR", "Lower CL", "Upper CL", "P-value")
z.everIsolated.inequality

#gini
reg.everIsolated.gini = miceadds::glm.cluster(isolated ~ gini*visibleWealth, 
      data = sample.reg, 
      cluster = "gameID",
      family = binomial(link = "logit"))
alpha <- 0.05
x.everIsolated.gini <- summary(reg.everIsolated.gini)
y.everIsolated.gini <- confint(reg.everIsolated.gini, level=1-alpha)
coef.everIsolated.gini <- x.everIsolated.gini[,1]
LowerCL.everIsolated.gini <- y.everIsolated.gini[,1]
UpperCL.everIsolated.gini <- y.everIsolated.gini[,2]
p.everIsolated.gini <-x.everIsolated.gini[,4]
#odds ratio
z.everIsolated.gini <- rbind(
  cbind(exp(coef.everIsolated.gini["gini"]), exp(LowerCL.everIsolated.gini["gini"]), exp(UpperCL.everIsolated.gini["gini"]), p.everIsolated.gini["gini"]),
  cbind(exp(coef.everIsolated.gini["visibleWealth"]), exp(LowerCL.everIsolated.gini["visibleWealth"]), exp(UpperCL.everIsolated.gini["visibleWealth"]), p.everIsolated.gini["visibleWealth"]),
  cbind(exp(coef.everIsolated.gini["gini:visibleWealth"]), exp(LowerCL.everIsolated.gini["gini:visibleWealth"]), exp(UpperCL.everIsolated.gini["gini:visibleWealth"]), p.everIsolated.gini["gini:visibleWealth"])
)
z.everIsolated.gini = data.frame(z.everIsolated.gini)
names(z.everIsolated.gini) = c("OR", "Lower CL", "Upper CL", "P-value")
z.everIsolated.gini


#initScore
reg.everIsolated.initScore = miceadds::glm.cluster(isolated ~ initScore*visibleWealth, 
      data = sample.reg[sample.reg$inequality=="high",], 
      cluster = "gameID",
      family = binomial(link = "logit"))
alpha <- 0.05
x.everIsolated.initScore <- summary(reg.everIsolated.initScore)
y.everIsolated.initScore <- confint(reg.everIsolated.initScore, level=1-alpha)
coef.everIsolated.initScore <- x.everIsolated.initScore[,1]
LowerCL.everIsolated.initScore <- y.everIsolated.initScore[,1]
UpperCL.everIsolated.initScore <- y.everIsolated.initScore[,2]
p.everIsolated.initScore <-x.everIsolated.initScore[,4]
#odds ratio
z.everIsolated.initScore <- rbind(
  cbind(exp(coef.everIsolated.initScore["initScore"]), exp(LowerCL.everIsolated.initScore["initScore"]), exp(UpperCL.everIsolated.initScore["initScore"]), p.everIsolated.initScore["initScore"]),
  cbind(exp(coef.everIsolated.initScore["visibleWealth"]), exp(LowerCL.everIsolated.initScore["visibleWealth"]), exp(UpperCL.everIsolated.initScore["visibleWealth"]), p.everIsolated.initScore["visibleWealth"]),
  cbind(exp(coef.everIsolated.initScore["initScore:visibleWealth"]), exp(LowerCL.everIsolated.initScore["initScore:visibleWealth"]), exp(UpperCL.everIsolated.initScore["initScore:visibleWealth"]), p.everIsolated.initScore["initScore:visibleWealth"])
)
z.everIsolated.initScore = data.frame(z.everIsolated.initScore)
names(z.everIsolated.initScore) = c("OR", "Lower CL", "Upper CL", "P-value")
z.everIsolated.initScore



```


#Links broken by ego, by wealth difference and wealth visibility
##How generous are people when alter defects, depending on wealth difference and visibility?
```{r}
ldata = ldata %>% mutate(decile=ntile(wealthDiff,10))

sum_linkBroken <- ldata %>% 
   group_by(decile, visibleWealth) %>%
   summarise(linkBroken = prop.table(table(connecting))["breakLink"])

sum_linkBroken = data.frame(sum_linkBroken)

g.linkBroken <- ggplot(data=sum_linkBroken,aes(x=decile,y=linkBroken,color = factor(visibleWealth)))+
  geom_point() +
  ggtitle("Proportions of links broken by ego, by wealth difference and wealth visibility") +
  xlab("Wealth difference decile (alter - ego)") +
  ylab("Proportions of links broken") +
  scale_color_discrete(name="Visibility") + 
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) 

g.linkBroken
```

#random forest model: wealth difference
```{r}
ldata.rf = ldata[c("connecting","wealthDiff","visibleWealth","egoWealth","ego_behavior","alter_behavior","round")]
ldata.rf = ldata.rf[complete.cases(ldata.rf),]
ldata.rf$connecting = factor(ldata.rf$connecting)
ldata.rf$round = factor(ldata.rf$round)
ldata.rf = ldata.rf %>% mutate(round = factor(round, labels = make.names(levels(round))))
ldata.rf$ego_behavior=as.factor(ifelse(ldata.rf$ego_behavior==1,"C","D"))
ldata.rf$alter_behavior=as.factor(ifelse(ldata.rf$alter_behavior==1,"C","D"))
ldata.rf$visibleWealth=as.factor(ldata.rf$visibleWealth)

set.seed(10)
control.rf <- trainControl(method='repeatedcv', 
                                 number=10, 
                                 repeats=3,
                                 search = 'random',
                                 classProbs=TRUE,
                                 summaryFunction = multiClassSummary,
                                 allowParallel = TRUE)

model.weights <- ifelse(ldata.rf$connecting == "breakLink",
                        (1/table(ldata.rf$connecting)[1]) * 0.5,
                        (1/table(ldata.rf$connecting)[2]) * 0.5)

rf <- caret::train(connecting ~ wealthDiff + visibleWealth + egoWealth + ego_behavior + alter_behavior + round,
                         data = ldata.rf,
                         method = 'rf',
                         metric = 'AUC',
                         tuneLength  = 30, 
                         verbose=TRUE,
                         weights=model.weights,
                         trControl = control.rf)
print(rf)

varImpPlot(rf$finalModel, type=2)
```

#Partial dependence plot: do wealth differrence and wealth visiblity explain isolation?
```{r, fig.width=12, fig.height=5}
pred.prob <- function(object, newdata) {
  pred <- predict(object, newdata, type="prob")
  prob.breakLink <- pred[, "breakLink"]
  mean(prob.breakLink)
}

pdp = partial(rf, pred.var = c("wealthDiff","visibleWealth","alter_behavior","egoWealth"), pred.fun = pred.prob, plot = FALSE)

pdp.df = data.frame(
  wealthDiff = pdp$wealthDiff,
  alter_behavior = pdp$alter_behavior,
  visibleWealth = pdp$visibleWealth,
  egoWealth = pdp$egoWealth,
  breakLink = pdp$yhat
)


# g.pdp <- ggplot(data=pdp.df,aes(x=wealthDiff,y=breakLink,color = factor(visibleWealth),shape=factor(alter_behavior)))+
#   geom_point() +
#   geom_line() +
#   ggtitle("Proportions of links broken by ego, by wealth difference and wealth visibility") +
#   xlab("Wealth difference (alter - ego)") +
#   ylab("Proportions of links broken") +
#   scale_color_discrete(name="Wealth visibility") + 
#   scale_shape(name="Behavior of alter") + 
#   theme_classic() +
#   theme(plot.title = element_text(hjust = 0.5)) 
# 
# g.pdp


g.visible = ggplot(data = pdp.df[pdp.df$visibleWealth=="Visible" & pdp.df$alter_behavior=="D",], 
                         aes(x = wealthDiff, y = egoWealth, fill = breakLink)) + 
  geom_tile() +
  ggtitle("Proportions of links broken by ego, \nby wealth difference and ego's wealth, \nwhen wealth is visible, \ngiven that alter defected") +
  scale_x_continuous("Wealth difference (alter - ego)") + 
  scale_y_continuous("Wealth of ego") +  
  scale_fill_continuous(type = "viridis", limits=c(0.3,0.8)) +
  labs(fill="Proportion of links \nbroken by ego")

g.invisible = ggplot(data = pdp.df[pdp.df$visibleWealth=="Not visible" & pdp.df$alter_behavior=="D",], 
                         aes(x = wealthDiff, y = egoWealth, fill = breakLink)) + 
  geom_tile() +
  ggtitle("Proportions of links broken by ego, \nby wealth difference and ego's wealth, \nwhen wealth is not visible, \ngiven that alter defected") +
  scale_x_continuous("Wealth difference (alter - ego)") + 
  scale_y_continuous("Wealth of ego") +  
  scale_fill_continuous(type = "viridis", limits=c(0.3,0.8)) +
  labs(fill="Proportion of links \nbroken by ego")

ggarrange(g.visible,g.invisible)

#rich and middle-class people become more generous when wealth is visible
```

#Regression: greater wealth difference and visible wealth
```{r}
ldata.reg = ldata[c("connecting","wealthDiff","visibleWealth","egoWealth","alter_behavior","round","gameID")]
ldata.reg = ldata.reg[complete.cases(ldata.reg),]
ldata.reg$connecting = ifelse(ldata.reg$connecting=="breakLink",1,0)
reg.link = miceadds::glm.cluster(connecting ~ wealthDiff*visibleWealth + egoWealth + alter_behavior + factor(round), 
      data = ldata.reg, 
      cluster = "gameID",
      family = binomial(link = "logit"))
summary(reg.link)
```




#random forest model: ego wealth and alter wealth
```{r}

ldata.rf = ldata[c("connecting","visibleWealth","egoWealth","alterWealth","ego_behavior","alter_behavior","round")]
ldata.rf = ldata.rf[complete.cases(ldata.rf),]
ldata.rf$connecting = factor(ldata.rf$connecting)
ldata.rf$round = factor(ldata.rf$round)
ldata.rf = ldata.rf %>% mutate(round = factor(round, labels = make.names(levels(round))))
ldata.rf$ego_behavior=as.factor(ifelse(ldata.rf$ego_behavior==1,"C","D"))
ldata.rf$alter_behavior=as.factor(ifelse(ldata.rf$alter_behavior==1,"C","D"))
ldata.rf$visibleWealth=as.factor(ldata.rf$visibleWealth)

set.seed(10)
control.rf <- trainControl(method='repeatedcv', 
                           number=10, 
                           repeats=3,
                           search = 'random',
                           classProbs=TRUE,
                           summaryFunction = multiClassSummary,
                           allowParallel = TRUE)

model.weights <- ifelse(ldata.rf$connecting == "breakLink",
                        (1/table(ldata.rf$connecting)[1]) * 0.5,
                        (1/table(ldata.rf$connecting)[2]) * 0.5)

rf <- caret::train(connecting ~ alterWealth + visibleWealth + egoWealth + ego_behavior + alter_behavior + round,
                   data = ldata.rf,
                   method = 'rf',
                   metric = 'AUC',
                   tuneLength  = 30, 
                   verbose=TRUE,
                   weights=model.weights,
                   trControl = control.rf)
print(rf)

varImpPlot(rf$finalModel, type=2)

```


#Partial dependence plot: do ego vs. alter's wealth and wealth visiblity explain isolation?
```{r, fig.width=12, fig.height=5}
pred.prob <- function(object, newdata) {
  pred <- predict(object, newdata, type="prob")
  prob.breakLink <- pred[, "breakLink"]
  mean(prob.breakLink)
}

pdp = partial(rf, pred.var = c("alterWealth","visibleWealth","alter_behavior","egoWealth"), pred.fun = pred.prob, plot = FALSE)

pdp.df = data.frame(
  alterWealth = pdp$alterWealth,
  alter_behavior = pdp$alter_behavior,
  visibleWealth = pdp$visibleWealth,
  egoWealth = pdp$egoWealth,
  breakLink = pdp$yhat
)


g.visible = ggplot(data = pdp.df[pdp.df$visibleWealth=="Visible" & pdp.df$alter_behavior=="D",], 
                   aes(x = alterWealth, y = egoWealth, fill = breakLink)) + 
  geom_tile() +
  ggtitle("Proportions of links broken by ego, \nby ego and alter's wealth, \nwhen wealth is visible, \ngiven that alter defected") +
  scale_x_continuous("Wealth of alter") + 
  scale_y_continuous("Wealth of ego") +  
  scale_fill_continuous(type = "viridis", limits=c(0.3,0.8)) +
  labs(fill="Proportion of links \nbroken by ego")


g.invisible = ggplot(data = pdp.df[pdp.df$visibleWealth=="Not visible" & pdp.df$alter_behavior=="D",], 
                     aes(x = alterWealth, y = egoWealth, fill = breakLink)) + 
  geom_tile() +
  ggtitle("Proportions of links broken by ego, \nby ego and alter's wealth, \nwhen wealth is not visible, \ngiven that alter defected") +
  scale_x_continuous("Wealth of alter") + 
  scale_y_continuous("Wealth of ego") +  
  scale_fill_continuous(type = "viridis", limits=c(0.3,0.8)) +
  labs(fill="Proportion of links \nbroken by ego")

ggarrange(g.visible,g.invisible)
```

